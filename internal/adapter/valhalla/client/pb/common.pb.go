// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v3.12.4
// source: common.proto

package pb

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type LanguageTag int32

const (
	LanguageTag_kUnspecified LanguageTag = 0
	LanguageTag_kAb          LanguageTag = 1
	LanguageTag_kAm          LanguageTag = 2
	LanguageTag_kAr          LanguageTag = 3
	LanguageTag_kAz          LanguageTag = 4
	LanguageTag_kBe          LanguageTag = 5
	LanguageTag_kBg          LanguageTag = 6
	LanguageTag_kBn          LanguageTag = 7
	LanguageTag_kBs          LanguageTag = 8
	LanguageTag_kCa          LanguageTag = 9
	LanguageTag_kCkb         LanguageTag = 10
	LanguageTag_kCs          LanguageTag = 11
	LanguageTag_kDa          LanguageTag = 12
	LanguageTag_kDe          LanguageTag = 13
	LanguageTag_kDv          LanguageTag = 14
	LanguageTag_kDz          LanguageTag = 15
	LanguageTag_kEl          LanguageTag = 16
	LanguageTag_kEn          LanguageTag = 17
	LanguageTag_kEs          LanguageTag = 18
	LanguageTag_kEt          LanguageTag = 19
	LanguageTag_kFa          LanguageTag = 20
	LanguageTag_kFi          LanguageTag = 21
	LanguageTag_kFr          LanguageTag = 22
	LanguageTag_kFy          LanguageTag = 23
	LanguageTag_kGl          LanguageTag = 24
	LanguageTag_kHe          LanguageTag = 25
	LanguageTag_kHr          LanguageTag = 26
	LanguageTag_kHu          LanguageTag = 27
	LanguageTag_kHy          LanguageTag = 28
	LanguageTag_kId          LanguageTag = 29
	LanguageTag_kIs          LanguageTag = 30
	LanguageTag_kIt          LanguageTag = 31
	LanguageTag_kJa          LanguageTag = 32
	LanguageTag_kKa          LanguageTag = 33
	LanguageTag_kKl          LanguageTag = 34
	LanguageTag_kKm          LanguageTag = 35
	LanguageTag_kKo          LanguageTag = 36
	LanguageTag_kLo          LanguageTag = 37
	LanguageTag_kLt          LanguageTag = 38
	LanguageTag_kLv          LanguageTag = 39
	LanguageTag_kMg          LanguageTag = 40
	LanguageTag_kMk          LanguageTag = 41
	LanguageTag_kMn          LanguageTag = 42
	LanguageTag_kMo          LanguageTag = 43
	LanguageTag_kMt          LanguageTag = 44
	LanguageTag_kMy          LanguageTag = 45
	LanguageTag_kNe          LanguageTag = 46
	LanguageTag_kNl          LanguageTag = 47
	LanguageTag_kNo          LanguageTag = 48
	LanguageTag_kOc          LanguageTag = 49
	LanguageTag_kPap         LanguageTag = 50
	LanguageTag_kPl          LanguageTag = 51
	LanguageTag_kPs          LanguageTag = 52
	LanguageTag_kPt          LanguageTag = 53
	LanguageTag_kRm          LanguageTag = 54
	LanguageTag_kRo          LanguageTag = 55
	LanguageTag_kRu          LanguageTag = 56
	LanguageTag_kSk          LanguageTag = 57
	LanguageTag_kSl          LanguageTag = 58
	LanguageTag_kSq          LanguageTag = 59
	LanguageTag_kSr          LanguageTag = 60
	LanguageTag_kSrLatn      LanguageTag = 61
	LanguageTag_kSv          LanguageTag = 62
	LanguageTag_kTg          LanguageTag = 63
	LanguageTag_kTh          LanguageTag = 64
	LanguageTag_kTk          LanguageTag = 65
	LanguageTag_kTr          LanguageTag = 66
	LanguageTag_kUk          LanguageTag = 67
	LanguageTag_kUr          LanguageTag = 68
	LanguageTag_kUz          LanguageTag = 69
	LanguageTag_kVi          LanguageTag = 70
	LanguageTag_kZh          LanguageTag = 71
	LanguageTag_kCy          LanguageTag = 72
)

// Enum value maps for LanguageTag.
var (
	LanguageTag_name = map[int32]string{
		0:  "kUnspecified",
		1:  "kAb",
		2:  "kAm",
		3:  "kAr",
		4:  "kAz",
		5:  "kBe",
		6:  "kBg",
		7:  "kBn",
		8:  "kBs",
		9:  "kCa",
		10: "kCkb",
		11: "kCs",
		12: "kDa",
		13: "kDe",
		14: "kDv",
		15: "kDz",
		16: "kEl",
		17: "kEn",
		18: "kEs",
		19: "kEt",
		20: "kFa",
		21: "kFi",
		22: "kFr",
		23: "kFy",
		24: "kGl",
		25: "kHe",
		26: "kHr",
		27: "kHu",
		28: "kHy",
		29: "kId",
		30: "kIs",
		31: "kIt",
		32: "kJa",
		33: "kKa",
		34: "kKl",
		35: "kKm",
		36: "kKo",
		37: "kLo",
		38: "kLt",
		39: "kLv",
		40: "kMg",
		41: "kMk",
		42: "kMn",
		43: "kMo",
		44: "kMt",
		45: "kMy",
		46: "kNe",
		47: "kNl",
		48: "kNo",
		49: "kOc",
		50: "kPap",
		51: "kPl",
		52: "kPs",
		53: "kPt",
		54: "kRm",
		55: "kRo",
		56: "kRu",
		57: "kSk",
		58: "kSl",
		59: "kSq",
		60: "kSr",
		61: "kSrLatn",
		62: "kSv",
		63: "kTg",
		64: "kTh",
		65: "kTk",
		66: "kTr",
		67: "kUk",
		68: "kUr",
		69: "kUz",
		70: "kVi",
		71: "kZh",
		72: "kCy",
	}
	LanguageTag_value = map[string]int32{
		"kUnspecified": 0,
		"kAb":          1,
		"kAm":          2,
		"kAr":          3,
		"kAz":          4,
		"kBe":          5,
		"kBg":          6,
		"kBn":          7,
		"kBs":          8,
		"kCa":          9,
		"kCkb":         10,
		"kCs":          11,
		"kDa":          12,
		"kDe":          13,
		"kDv":          14,
		"kDz":          15,
		"kEl":          16,
		"kEn":          17,
		"kEs":          18,
		"kEt":          19,
		"kFa":          20,
		"kFi":          21,
		"kFr":          22,
		"kFy":          23,
		"kGl":          24,
		"kHe":          25,
		"kHr":          26,
		"kHu":          27,
		"kHy":          28,
		"kId":          29,
		"kIs":          30,
		"kIt":          31,
		"kJa":          32,
		"kKa":          33,
		"kKl":          34,
		"kKm":          35,
		"kKo":          36,
		"kLo":          37,
		"kLt":          38,
		"kLv":          39,
		"kMg":          40,
		"kMk":          41,
		"kMn":          42,
		"kMo":          43,
		"kMt":          44,
		"kMy":          45,
		"kNe":          46,
		"kNl":          47,
		"kNo":          48,
		"kOc":          49,
		"kPap":         50,
		"kPl":          51,
		"kPs":          52,
		"kPt":          53,
		"kRm":          54,
		"kRo":          55,
		"kRu":          56,
		"kSk":          57,
		"kSl":          58,
		"kSq":          59,
		"kSr":          60,
		"kSrLatn":      61,
		"kSv":          62,
		"kTg":          63,
		"kTh":          64,
		"kTk":          65,
		"kTr":          66,
		"kUk":          67,
		"kUr":          68,
		"kUz":          69,
		"kVi":          70,
		"kZh":          71,
		"kCy":          72,
	}
)

func (x LanguageTag) Enum() *LanguageTag {
	p := new(LanguageTag)
	*p = x
	return p
}

func (x LanguageTag) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (LanguageTag) Descriptor() protoreflect.EnumDescriptor {
	return file_common_proto_enumTypes[0].Descriptor()
}

func (LanguageTag) Type() protoreflect.EnumType {
	return &file_common_proto_enumTypes[0]
}

func (x LanguageTag) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use LanguageTag.Descriptor instead.
func (LanguageTag) EnumDescriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{0}
}

type RoadClass int32

const (
	RoadClass_kMotorway     RoadClass = 0
	RoadClass_kTrunk        RoadClass = 1
	RoadClass_kPrimary      RoadClass = 2
	RoadClass_kSecondary    RoadClass = 3
	RoadClass_kTertiary     RoadClass = 4
	RoadClass_kUnclassified RoadClass = 5
	RoadClass_kResidential  RoadClass = 6
	RoadClass_kServiceOther RoadClass = 7
)

// Enum value maps for RoadClass.
var (
	RoadClass_name = map[int32]string{
		0: "kMotorway",
		1: "kTrunk",
		2: "kPrimary",
		3: "kSecondary",
		4: "kTertiary",
		5: "kUnclassified",
		6: "kResidential",
		7: "kServiceOther",
	}
	RoadClass_value = map[string]int32{
		"kMotorway":     0,
		"kTrunk":        1,
		"kPrimary":      2,
		"kSecondary":    3,
		"kTertiary":     4,
		"kUnclassified": 5,
		"kResidential":  6,
		"kServiceOther": 7,
	}
)

func (x RoadClass) Enum() *RoadClass {
	p := new(RoadClass)
	*p = x
	return p
}

func (x RoadClass) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (RoadClass) Descriptor() protoreflect.EnumDescriptor {
	return file_common_proto_enumTypes[1].Descriptor()
}

func (RoadClass) Type() protoreflect.EnumType {
	return &file_common_proto_enumTypes[1]
}

func (x RoadClass) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use RoadClass.Descriptor instead.
func (RoadClass) EnumDescriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{1}
}

type TravelMode int32

const (
	TravelMode_kDrive      TravelMode = 0
	TravelMode_kPedestrian TravelMode = 1
	TravelMode_kBicycle    TravelMode = 2
	TravelMode_kTransit    TravelMode = 3
)

// Enum value maps for TravelMode.
var (
	TravelMode_name = map[int32]string{
		0: "kDrive",
		1: "kPedestrian",
		2: "kBicycle",
		3: "kTransit",
	}
	TravelMode_value = map[string]int32{
		"kDrive":      0,
		"kPedestrian": 1,
		"kBicycle":    2,
		"kTransit":    3,
	}
)

func (x TravelMode) Enum() *TravelMode {
	p := new(TravelMode)
	*p = x
	return p
}

func (x TravelMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TravelMode) Descriptor() protoreflect.EnumDescriptor {
	return file_common_proto_enumTypes[2].Descriptor()
}

func (TravelMode) Type() protoreflect.EnumType {
	return &file_common_proto_enumTypes[2]
}

func (x TravelMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TravelMode.Descriptor instead.
func (TravelMode) EnumDescriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{2}
}

// TODO: review and update as needed
type VehicleType int32

const (
	VehicleType_kCar          VehicleType = 0
	VehicleType_kMotorcycle   VehicleType = 1
	VehicleType_kAutoBus      VehicleType = 2
	VehicleType_kTruck        VehicleType = 3
	VehicleType_kMotorScooter VehicleType = 4
)

// Enum value maps for VehicleType.
var (
	VehicleType_name = map[int32]string{
		0: "kCar",
		1: "kMotorcycle",
		2: "kAutoBus",
		3: "kTruck",
		4: "kMotorScooter",
	}
	VehicleType_value = map[string]int32{
		"kCar":          0,
		"kMotorcycle":   1,
		"kAutoBus":      2,
		"kTruck":        3,
		"kMotorScooter": 4,
	}
)

func (x VehicleType) Enum() *VehicleType {
	p := new(VehicleType)
	*p = x
	return p
}

func (x VehicleType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (VehicleType) Descriptor() protoreflect.EnumDescriptor {
	return file_common_proto_enumTypes[3].Descriptor()
}

func (VehicleType) Type() protoreflect.EnumType {
	return &file_common_proto_enumTypes[3]
}

func (x VehicleType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use VehicleType.Descriptor instead.
func (VehicleType) EnumDescriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{3}
}

// TODO: review and update as needed
type PedestrianType int32

const (
	PedestrianType_kFoot       PedestrianType = 0
	PedestrianType_kWheelchair PedestrianType = 1
	PedestrianType_kBlind      PedestrianType = 2
)

// Enum value maps for PedestrianType.
var (
	PedestrianType_name = map[int32]string{
		0: "kFoot",
		1: "kWheelchair",
		2: "kBlind",
	}
	PedestrianType_value = map[string]int32{
		"kFoot":       0,
		"kWheelchair": 1,
		"kBlind":      2,
	}
)

func (x PedestrianType) Enum() *PedestrianType {
	p := new(PedestrianType)
	*p = x
	return p
}

func (x PedestrianType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PedestrianType) Descriptor() protoreflect.EnumDescriptor {
	return file_common_proto_enumTypes[4].Descriptor()
}

func (PedestrianType) Type() protoreflect.EnumType {
	return &file_common_proto_enumTypes[4]
}

func (x PedestrianType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PedestrianType.Descriptor instead.
func (PedestrianType) EnumDescriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{4}
}

type BicycleType int32

const (
	BicycleType_kRoad     BicycleType = 0
	BicycleType_kCross    BicycleType = 1
	BicycleType_kHybrid   BicycleType = 2
	BicycleType_kMountain BicycleType = 3
)

// Enum value maps for BicycleType.
var (
	BicycleType_name = map[int32]string{
		0: "kRoad",
		1: "kCross",
		2: "kHybrid",
		3: "kMountain",
	}
	BicycleType_value = map[string]int32{
		"kRoad":     0,
		"kCross":    1,
		"kHybrid":   2,
		"kMountain": 3,
	}
)

func (x BicycleType) Enum() *BicycleType {
	p := new(BicycleType)
	*p = x
	return p
}

func (x BicycleType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (BicycleType) Descriptor() protoreflect.EnumDescriptor {
	return file_common_proto_enumTypes[5].Descriptor()
}

func (BicycleType) Type() protoreflect.EnumType {
	return &file_common_proto_enumTypes[5]
}

func (x BicycleType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use BicycleType.Descriptor instead.
func (BicycleType) EnumDescriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{5}
}

type TransitType int32

const (
	TransitType_kTram      TransitType = 0
	TransitType_kMetro     TransitType = 1
	TransitType_kRail      TransitType = 2
	TransitType_kBus       TransitType = 3
	TransitType_kFerry     TransitType = 4
	TransitType_kCableCar  TransitType = 5
	TransitType_kGondola   TransitType = 6
	TransitType_kFunicular TransitType = 7
)

// Enum value maps for TransitType.
var (
	TransitType_name = map[int32]string{
		0: "kTram",
		1: "kMetro",
		2: "kRail",
		3: "kBus",
		4: "kFerry",
		5: "kCableCar",
		6: "kGondola",
		7: "kFunicular",
	}
	TransitType_value = map[string]int32{
		"kTram":      0,
		"kMetro":     1,
		"kRail":      2,
		"kBus":       3,
		"kFerry":     4,
		"kCableCar":  5,
		"kGondola":   6,
		"kFunicular": 7,
	}
)

func (x TransitType) Enum() *TransitType {
	p := new(TransitType)
	*p = x
	return p
}

func (x TransitType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TransitType) Descriptor() protoreflect.EnumDescriptor {
	return file_common_proto_enumTypes[6].Descriptor()
}

func (TransitType) Type() protoreflect.EnumType {
	return &file_common_proto_enumTypes[6]
}

func (x TransitType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TransitType.Descriptor instead.
func (TransitType) EnumDescriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{6}
}

type RouteLandmark_Type int32

const (
	RouteLandmark_kUnused       RouteLandmark_Type = 0
	RouteLandmark_kFuel         RouteLandmark_Type = 1
	RouteLandmark_kPostOffice   RouteLandmark_Type = 2
	RouteLandmark_kPolice       RouteLandmark_Type = 3
	RouteLandmark_kFireStation  RouteLandmark_Type = 4
	RouteLandmark_kCarWash      RouteLandmark_Type = 5
	RouteLandmark_kRestaurant   RouteLandmark_Type = 6
	RouteLandmark_kFastFood     RouteLandmark_Type = 7
	RouteLandmark_kCafe         RouteLandmark_Type = 8
	RouteLandmark_kBank         RouteLandmark_Type = 9
	RouteLandmark_kPharmacy     RouteLandmark_Type = 10
	RouteLandmark_kKindergarten RouteLandmark_Type = 11
	RouteLandmark_kBar          RouteLandmark_Type = 12
	RouteLandmark_kHospital     RouteLandmark_Type = 13
	RouteLandmark_kPub          RouteLandmark_Type = 14
	RouteLandmark_kClinic       RouteLandmark_Type = 15
	RouteLandmark_kTheatre      RouteLandmark_Type = 16
	RouteLandmark_kCinema       RouteLandmark_Type = 17
	RouteLandmark_kCasino       RouteLandmark_Type = 18
)

// Enum value maps for RouteLandmark_Type.
var (
	RouteLandmark_Type_name = map[int32]string{
		0:  "kUnused",
		1:  "kFuel",
		2:  "kPostOffice",
		3:  "kPolice",
		4:  "kFireStation",
		5:  "kCarWash",
		6:  "kRestaurant",
		7:  "kFastFood",
		8:  "kCafe",
		9:  "kBank",
		10: "kPharmacy",
		11: "kKindergarten",
		12: "kBar",
		13: "kHospital",
		14: "kPub",
		15: "kClinic",
		16: "kTheatre",
		17: "kCinema",
		18: "kCasino",
	}
	RouteLandmark_Type_value = map[string]int32{
		"kUnused":       0,
		"kFuel":         1,
		"kPostOffice":   2,
		"kPolice":       3,
		"kFireStation":  4,
		"kCarWash":      5,
		"kRestaurant":   6,
		"kFastFood":     7,
		"kCafe":         8,
		"kBank":         9,
		"kPharmacy":     10,
		"kKindergarten": 11,
		"kBar":          12,
		"kHospital":     13,
		"kPub":          14,
		"kClinic":       15,
		"kTheatre":      16,
		"kCinema":       17,
		"kCasino":       18,
	}
)

func (x RouteLandmark_Type) Enum() *RouteLandmark_Type {
	p := new(RouteLandmark_Type)
	*p = x
	return p
}

func (x RouteLandmark_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (RouteLandmark_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_common_proto_enumTypes[7].Descriptor()
}

func (RouteLandmark_Type) Type() protoreflect.EnumType {
	return &file_common_proto_enumTypes[7]
}

func (x RouteLandmark_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use RouteLandmark_Type.Descriptor instead.
func (RouteLandmark_Type) EnumDescriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{1, 0}
}

type Location_Type int32

const (
	Location_kBreak        Location_Type = 0
	Location_kThrough      Location_Type = 1
	Location_kVia          Location_Type = 2
	Location_kBreakThrough Location_Type = 3
)

// Enum value maps for Location_Type.
var (
	Location_Type_name = map[int32]string{
		0: "kBreak",
		1: "kThrough",
		2: "kVia",
		3: "kBreakThrough",
	}
	Location_Type_value = map[string]int32{
		"kBreak":        0,
		"kThrough":      1,
		"kVia":          2,
		"kBreakThrough": 3,
	}
)

func (x Location_Type) Enum() *Location_Type {
	p := new(Location_Type)
	*p = x
	return p
}

func (x Location_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Location_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_common_proto_enumTypes[8].Descriptor()
}

func (Location_Type) Type() protoreflect.EnumType {
	return &file_common_proto_enumTypes[8]
}

func (x Location_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Location_Type.Descriptor instead.
func (Location_Type) EnumDescriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{6, 0}
}

type Location_PreferredSide int32

const (
	Location_either   Location_PreferredSide = 0
	Location_same     Location_PreferredSide = 1
	Location_opposite Location_PreferredSide = 2
)

// Enum value maps for Location_PreferredSide.
var (
	Location_PreferredSide_name = map[int32]string{
		0: "either",
		1: "same",
		2: "opposite",
	}
	Location_PreferredSide_value = map[string]int32{
		"either":   0,
		"same":     1,
		"opposite": 2,
	}
)

func (x Location_PreferredSide) Enum() *Location_PreferredSide {
	p := new(Location_PreferredSide)
	*p = x
	return p
}

func (x Location_PreferredSide) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Location_PreferredSide) Descriptor() protoreflect.EnumDescriptor {
	return file_common_proto_enumTypes[9].Descriptor()
}

func (Location_PreferredSide) Type() protoreflect.EnumType {
	return &file_common_proto_enumTypes[9]
}

func (x Location_PreferredSide) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Location_PreferredSide.Descriptor instead.
func (Location_PreferredSide) EnumDescriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{6, 1}
}

type Location_SideOfStreet int32

const (
	Location_kNone  Location_SideOfStreet = 0
	Location_kLeft  Location_SideOfStreet = 1
	Location_kRight Location_SideOfStreet = 2
)

// Enum value maps for Location_SideOfStreet.
var (
	Location_SideOfStreet_name = map[int32]string{
		0: "kNone",
		1: "kLeft",
		2: "kRight",
	}
	Location_SideOfStreet_value = map[string]int32{
		"kNone":  0,
		"kLeft":  1,
		"kRight": 2,
	}
)

func (x Location_SideOfStreet) Enum() *Location_SideOfStreet {
	p := new(Location_SideOfStreet)
	*p = x
	return p
}

func (x Location_SideOfStreet) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Location_SideOfStreet) Descriptor() protoreflect.EnumDescriptor {
	return file_common_proto_enumTypes[10].Descriptor()
}

func (Location_SideOfStreet) Type() protoreflect.EnumType {
	return &file_common_proto_enumTypes[10]
}

func (x Location_SideOfStreet) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Location_SideOfStreet.Descriptor instead.
func (Location_SideOfStreet) EnumDescriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{6, 2}
}

type TransitPlatformInfo_Type int32

const (
	TransitPlatformInfo_kStop    TransitPlatformInfo_Type = 0
	TransitPlatformInfo_kStation TransitPlatformInfo_Type = 1
)

// Enum value maps for TransitPlatformInfo_Type.
var (
	TransitPlatformInfo_Type_name = map[int32]string{
		0: "kStop",
		1: "kStation",
	}
	TransitPlatformInfo_Type_value = map[string]int32{
		"kStop":    0,
		"kStation": 1,
	}
)

func (x TransitPlatformInfo_Type) Enum() *TransitPlatformInfo_Type {
	p := new(TransitPlatformInfo_Type)
	*p = x
	return p
}

func (x TransitPlatformInfo_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TransitPlatformInfo_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_common_proto_enumTypes[11].Descriptor()
}

func (TransitPlatformInfo_Type) Type() protoreflect.EnumType {
	return &file_common_proto_enumTypes[11]
}

func (x TransitPlatformInfo_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TransitPlatformInfo_Type.Descriptor instead.
func (TransitPlatformInfo_Type) EnumDescriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{10, 0}
}

type Pronunciation_Alphabet int32

const (
	Pronunciation_kNone     Pronunciation_Alphabet = 0
	Pronunciation_kIpa      Pronunciation_Alphabet = 1
	Pronunciation_kKatakana Pronunciation_Alphabet = 2
	Pronunciation_kJeita    Pronunciation_Alphabet = 3
	Pronunciation_kNtSampa  Pronunciation_Alphabet = 4
)

// Enum value maps for Pronunciation_Alphabet.
var (
	Pronunciation_Alphabet_name = map[int32]string{
		0: "kNone",
		1: "kIpa",
		2: "kKatakana",
		3: "kJeita",
		4: "kNtSampa",
	}
	Pronunciation_Alphabet_value = map[string]int32{
		"kNone":     0,
		"kIpa":      1,
		"kKatakana": 2,
		"kJeita":    3,
		"kNtSampa":  4,
	}
)

func (x Pronunciation_Alphabet) Enum() *Pronunciation_Alphabet {
	p := new(Pronunciation_Alphabet)
	*p = x
	return p
}

func (x Pronunciation_Alphabet) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Pronunciation_Alphabet) Descriptor() protoreflect.EnumDescriptor {
	return file_common_proto_enumTypes[12].Descriptor()
}

func (Pronunciation_Alphabet) Type() protoreflect.EnumType {
	return &file_common_proto_enumTypes[12]
}

func (x Pronunciation_Alphabet) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Pronunciation_Alphabet.Descriptor instead.
func (Pronunciation_Alphabet) EnumDescriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{12, 0}
}

type TurnLane_State int32

const (
	TurnLane_kInvalid TurnLane_State = 0
	TurnLane_kValid   TurnLane_State = 1
	TurnLane_kActive  TurnLane_State = 2
)

// Enum value maps for TurnLane_State.
var (
	TurnLane_State_name = map[int32]string{
		0: "kInvalid",
		1: "kValid",
		2: "kActive",
	}
	TurnLane_State_value = map[string]int32{
		"kInvalid": 0,
		"kValid":   1,
		"kActive":  2,
	}
)

func (x TurnLane_State) Enum() *TurnLane_State {
	p := new(TurnLane_State)
	*p = x
	return p
}

func (x TurnLane_State) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TurnLane_State) Descriptor() protoreflect.EnumDescriptor {
	return file_common_proto_enumTypes[13].Descriptor()
}

func (TurnLane_State) Type() protoreflect.EnumType {
	return &file_common_proto_enumTypes[13]
}

func (x TurnLane_State) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TurnLane_State.Descriptor instead.
func (TurnLane_State) EnumDescriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{14, 0}
}

// dont renumber these they match the c++ definitions
type TaggedValue_Type int32

const (
	TaggedValue_kNone                   TaggedValue_Type = 0
	TaggedValue_kLayer                  TaggedValue_Type = 1
	TaggedValue_kPronunciation          TaggedValue_Type = 2
	TaggedValue_kBssInfo                TaggedValue_Type = 3
	TaggedValue_kLevel                  TaggedValue_Type = 4
	TaggedValue_kLevelRef               TaggedValue_Type = 5
	TaggedValue_kLandmark               TaggedValue_Type = 6
	TaggedValue_kConditionalSpeedLimits TaggedValue_Type = 7
	TaggedValue_kLevels                 TaggedValue_Type = 8
	TaggedValue_kTunnel                 TaggedValue_Type = 49
	TaggedValue_kBridge                 TaggedValue_Type = 50
)

// Enum value maps for TaggedValue_Type.
var (
	TaggedValue_Type_name = map[int32]string{
		0:  "kNone",
		1:  "kLayer",
		2:  "kPronunciation",
		3:  "kBssInfo",
		4:  "kLevel",
		5:  "kLevelRef",
		6:  "kLandmark",
		7:  "kConditionalSpeedLimits",
		8:  "kLevels",
		49: "kTunnel",
		50: "kBridge",
	}
	TaggedValue_Type_value = map[string]int32{
		"kNone":                   0,
		"kLayer":                  1,
		"kPronunciation":          2,
		"kBssInfo":                3,
		"kLevel":                  4,
		"kLevelRef":               5,
		"kLandmark":               6,
		"kConditionalSpeedLimits": 7,
		"kLevels":                 8,
		"kTunnel":                 49,
		"kBridge":                 50,
	}
)

func (x TaggedValue_Type) Enum() *TaggedValue_Type {
	p := new(TaggedValue_Type)
	*p = x
	return p
}

func (x TaggedValue_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TaggedValue_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_common_proto_enumTypes[14].Descriptor()
}

func (TaggedValue_Type) Type() protoreflect.EnumType {
	return &file_common_proto_enumTypes[14]
}

func (x TaggedValue_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TaggedValue_Type.Descriptor instead.
func (TaggedValue_Type) EnumDescriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{15, 0}
}

type LatLng struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to HasLat:
	//
	//	*LatLng_Lat
	HasLat isLatLng_HasLat `protobuf_oneof:"has_lat"`
	// Types that are valid to be assigned to HasLng:
	//
	//	*LatLng_Lng
	HasLng        isLatLng_HasLng `protobuf_oneof:"has_lng"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LatLng) Reset() {
	*x = LatLng{}
	mi := &file_common_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LatLng) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LatLng) ProtoMessage() {}

func (x *LatLng) ProtoReflect() protoreflect.Message {
	mi := &file_common_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LatLng.ProtoReflect.Descriptor instead.
func (*LatLng) Descriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{0}
}

func (x *LatLng) GetHasLat() isLatLng_HasLat {
	if x != nil {
		return x.HasLat
	}
	return nil
}

func (x *LatLng) GetLat() float64 {
	if x != nil {
		if x, ok := x.HasLat.(*LatLng_Lat); ok {
			return x.Lat
		}
	}
	return 0
}

func (x *LatLng) GetHasLng() isLatLng_HasLng {
	if x != nil {
		return x.HasLng
	}
	return nil
}

func (x *LatLng) GetLng() float64 {
	if x != nil {
		if x, ok := x.HasLng.(*LatLng_Lng); ok {
			return x.Lng
		}
	}
	return 0
}

type isLatLng_HasLat interface {
	isLatLng_HasLat()
}

type LatLng_Lat struct {
	Lat float64 `protobuf:"fixed64,1,opt,name=lat,proto3,oneof"`
}

func (*LatLng_Lat) isLatLng_HasLat() {}

type isLatLng_HasLng interface {
	isLatLng_HasLng()
}

type LatLng_Lng struct {
	Lng float64 `protobuf:"fixed64,2,opt,name=lng,proto3,oneof"`
}

func (*LatLng_Lng) isLatLng_HasLng() {}

type RouteLandmark struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name     string             `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Type     RouteLandmark_Type `protobuf:"varint,2,opt,name=type,proto3,enum=valhalla.RouteLandmark_Type" json:"type,omitempty"`
	LatLng   *LatLng            `protobuf:"bytes,3,opt,name=lat_lng,json=latLng,proto3" json:"lat_lng,omitempty"`
	Distance float64            `protobuf:"fixed64,4,opt,name=distance,proto3" json:"distance,omitempty"` // landmark's distance along the trip edge. in maneuvers it's landmark's distance to the maneuver
	Right         bool                   `protobuf:"varint,5,opt,name=right,proto3" json:"right,omitempty"`        // landmark is to the right of the route that comes before the maneuver
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RouteLandmark) Reset() {
	*x = RouteLandmark{}
	mi := &file_common_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RouteLandmark) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteLandmark) ProtoMessage() {}

func (x *RouteLandmark) ProtoReflect() protoreflect.Message {
	mi := &file_common_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteLandmark.ProtoReflect.Descriptor instead.
func (*RouteLandmark) Descriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{1}
}

func (x *RouteLandmark) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *RouteLandmark) GetType() RouteLandmark_Type {
	if x != nil {
		return x.Type
	}
	return RouteLandmark_kUnused
}

func (x *RouteLandmark) GetLatLng() *LatLng {
	if x != nil {
		return x.LatLng
	}
	return nil
}

func (x *RouteLandmark) GetDistance() float64 {
	if x != nil {
		return x.Distance
	}
	return 0
}

func (x *RouteLandmark) GetRight() bool {
	if x != nil {
		return x.Right
	}
	return false
}

type BoundingBox struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	MinLl         *LatLng                `protobuf:"bytes,1,opt,name=min_ll,json=minLl,proto3" json:"min_ll,omitempty"`
	MaxLl         *LatLng                `protobuf:"bytes,2,opt,name=max_ll,json=maxLl,proto3" json:"max_ll,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BoundingBox) Reset() {
	*x = BoundingBox{}
	mi := &file_common_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BoundingBox) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BoundingBox) ProtoMessage() {}

func (x *BoundingBox) ProtoReflect() protoreflect.Message {
	mi := &file_common_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BoundingBox.ProtoReflect.Descriptor instead.
func (*BoundingBox) Descriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{2}
}

func (x *BoundingBox) GetMinLl() *LatLng {
	if x != nil {
		return x.MinLl
	}
	return nil
}

func (x *BoundingBox) GetMaxLl() *LatLng {
	if x != nil {
		return x.MaxLl
	}
	return nil
}

type SearchFilter struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// frc
	//
	// Types that are valid to be assigned to HasMinRoadClass:
	//
	//	*SearchFilter_MinRoadClass
	HasMinRoadClass isSearchFilter_HasMinRoadClass `protobuf_oneof:"has_min_road_class"`
	// Types that are valid to be assigned to HasMaxRoadClass:
	//
	//	*SearchFilter_MaxRoadClass
	HasMaxRoadClass isSearchFilter_HasMaxRoadClass `protobuf_oneof:"has_max_road_class"`
	// form of way
	ExcludeTunnel bool `protobuf:"varint,3,opt,name=exclude_tunnel,json=excludeTunnel,proto3" json:"exclude_tunnel,omitempty"` // whether to exclude tunnels from loki results [default = false]
	ExcludeBridge bool `protobuf:"varint,4,opt,name=exclude_bridge,json=excludeBridge,proto3" json:"exclude_bridge,omitempty"` // whether to exclude bridges from loki results [default = false]
	ExcludeRamp   bool `protobuf:"varint,5,opt,name=exclude_ramp,json=excludeRamp,proto3" json:"exclude_ramp,omitempty"`       // whether to exclude roads with ramp use from loki results [default = false]
	// Types that are valid to be assigned to HasExcludeClosures:
	//
	//	*SearchFilter_ExcludeClosures
	HasExcludeClosures isSearchFilter_HasExcludeClosures `protobuf_oneof:"has_exclude_closures"`
	ExcludeToll        bool                              `protobuf:"varint,7,opt,name=exclude_toll,json=excludeToll,proto3" json:"exclude_toll,omitempty"`    // whether to exclude toll routes from loki results [default = false]
	ExcludeFerry       bool                              `protobuf:"varint,8,opt,name=exclude_ferry,json=excludeFerry,proto3" json:"exclude_ferry,omitempty"` // whether to exclude ferry routes from loki results [default = false]
	// Types that are valid to be assigned to HasLevel:
	//
	//	*SearchFilter_Level
	HasLevel      isSearchFilter_HasLevel `protobuf_oneof:"has_level"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SearchFilter) Reset() {
	*x = SearchFilter{}
	mi := &file_common_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SearchFilter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SearchFilter) ProtoMessage() {}

func (x *SearchFilter) ProtoReflect() protoreflect.Message {
	mi := &file_common_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SearchFilter.ProtoReflect.Descriptor instead.
func (*SearchFilter) Descriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{3}
}

func (x *SearchFilter) GetHasMinRoadClass() isSearchFilter_HasMinRoadClass {
	if x != nil {
		return x.HasMinRoadClass
	}
	return nil
}

func (x *SearchFilter) GetMinRoadClass() RoadClass {
	if x != nil {
		if x, ok := x.HasMinRoadClass.(*SearchFilter_MinRoadClass); ok {
			return x.MinRoadClass
		}
	}
	return RoadClass_kMotorway
}

func (x *SearchFilter) GetHasMaxRoadClass() isSearchFilter_HasMaxRoadClass {
	if x != nil {
		return x.HasMaxRoadClass
	}
	return nil
}

func (x *SearchFilter) GetMaxRoadClass() RoadClass {
	if x != nil {
		if x, ok := x.HasMaxRoadClass.(*SearchFilter_MaxRoadClass); ok {
			return x.MaxRoadClass
		}
	}
	return RoadClass_kMotorway
}

func (x *SearchFilter) GetExcludeTunnel() bool {
	if x != nil {
		return x.ExcludeTunnel
	}
	return false
}

func (x *SearchFilter) GetExcludeBridge() bool {
	if x != nil {
		return x.ExcludeBridge
	}
	return false
}

func (x *SearchFilter) GetExcludeRamp() bool {
	if x != nil {
		return x.ExcludeRamp
	}
	return false
}

func (x *SearchFilter) GetHasExcludeClosures() isSearchFilter_HasExcludeClosures {
	if x != nil {
		return x.HasExcludeClosures
	}
	return nil
}

func (x *SearchFilter) GetExcludeClosures() bool {
	if x != nil {
		if x, ok := x.HasExcludeClosures.(*SearchFilter_ExcludeClosures); ok {
			return x.ExcludeClosures
		}
	}
	return false
}

func (x *SearchFilter) GetExcludeToll() bool {
	if x != nil {
		return x.ExcludeToll
	}
	return false
}

func (x *SearchFilter) GetExcludeFerry() bool {
	if x != nil {
		return x.ExcludeFerry
	}
	return false
}

func (x *SearchFilter) GetHasLevel() isSearchFilter_HasLevel {
	if x != nil {
		return x.HasLevel
	}
	return nil
}

func (x *SearchFilter) GetLevel() float32 {
	if x != nil {
		if x, ok := x.HasLevel.(*SearchFilter_Level); ok {
			return x.Level
		}
	}
	return 0
}

type isSearchFilter_HasMinRoadClass interface {
	isSearchFilter_HasMinRoadClass()
}

type SearchFilter_MinRoadClass struct {
	MinRoadClass RoadClass `protobuf:"varint,1,opt,name=min_road_class,json=minRoadClass,proto3,enum=valhalla.RoadClass,oneof"` // lowest road class to allow in loki results [default = kServiceOther]
}

func (*SearchFilter_MinRoadClass) isSearchFilter_HasMinRoadClass() {}

type isSearchFilter_HasMaxRoadClass interface {
	isSearchFilter_HasMaxRoadClass()
}

type SearchFilter_MaxRoadClass struct {
	MaxRoadClass RoadClass `protobuf:"varint,2,opt,name=max_road_class,json=maxRoadClass,proto3,enum=valhalla.RoadClass,oneof"` // highest road class to allow in loki results [default = kMotorway]
}

func (*SearchFilter_MaxRoadClass) isSearchFilter_HasMaxRoadClass() {}

type isSearchFilter_HasExcludeClosures interface {
	isSearchFilter_HasExcludeClosures()
}

type SearchFilter_ExcludeClosures struct {
	ExcludeClosures bool `protobuf:"varint,6,opt,name=exclude_closures,json=excludeClosures,proto3,oneof"` // whether to exclude roads marked as closed due to traffic [default = true]
}

func (*SearchFilter_ExcludeClosures) isSearchFilter_HasExcludeClosures() {}

type isSearchFilter_HasLevel interface {
	isSearchFilter_HasLevel()
}

type SearchFilter_Level struct {
	Level float32 `protobuf:"fixed32,9,opt,name=level,proto3,oneof"` // level to filter edges by
}

func (*SearchFilter_Level) isSearchFilter_HasLevel() {}

type PathEdge struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	GraphId       uint64                 `protobuf:"varint,1,opt,name=graph_id,json=graphId,proto3" json:"graph_id,omitempty"`
	PercentAlong float64               `protobuf:"fixed64,2,opt,name=percent_along,json=percentAlong,proto3" json:"percent_along,omitempty"`
	Ll           *LatLng               `protobuf:"bytes,3,opt,name=ll,proto3" json:"ll,omitempty"`
	SideOfStreet Location_SideOfStreet `protobuf:"varint,4,opt,name=side_of_street,json=sideOfStreet,proto3,enum=valhalla.Location_SideOfStreet" json:"side_of_street,omitempty"`
	Distance     float64               `protobuf:"fixed64,5,opt,name=distance,proto3" json:"distance,omitempty"`
	BeginNode     bool                   `protobuf:"varint,7,opt,name=begin_node,json=beginNode,proto3" json:"begin_node,omitempty"`
	EndNode       bool                   `protobuf:"varint,8,opt,name=end_node,json=endNode,proto3" json:"end_node,omitempty"`
	Names         []string               `protobuf:"bytes,10,rep,name=names,proto3" json:"names,omitempty"`
	OutboundReach int32                  `protobuf:"varint,11,opt,name=outbound_reach,json=outboundReach,proto3" json:"outbound_reach,omitempty"`
	InboundReach  int32                  `protobuf:"varint,12,opt,name=inbound_reach,json=inboundReach,proto3" json:"inbound_reach,omitempty"`
	Heading       float32                `protobuf:"fixed32,13,opt,name=heading,proto3" json:"heading,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PathEdge) Reset() {
	*x = PathEdge{}
	mi := &file_common_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PathEdge) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PathEdge) ProtoMessage() {}

func (x *PathEdge) ProtoReflect() protoreflect.Message {
	mi := &file_common_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PathEdge.ProtoReflect.Descriptor instead.
func (*PathEdge) Descriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{4}
}

func (x *PathEdge) GetGraphId() uint64 {
	if x != nil {
		return x.GraphId
	}
	return 0
}

func (x *PathEdge) GetPercentAlong() float64 {
	if x != nil {
		return x.PercentAlong
	}
	return 0
}

func (x *PathEdge) GetLl() *LatLng {
	if x != nil {
		return x.Ll
	}
	return nil
}

func (x *PathEdge) GetSideOfStreet() Location_SideOfStreet {
	if x != nil {
		return x.SideOfStreet
	}
	return Location_kNone
}

func (x *PathEdge) GetDistance() float64 {
	if x != nil {
		return x.Distance
	}
	return 0
}

func (x *PathEdge) GetBeginNode() bool {
	if x != nil {
		return x.BeginNode
	}
	return false
}

func (x *PathEdge) GetEndNode() bool {
	if x != nil {
		return x.EndNode
	}
	return false
}

func (x *PathEdge) GetNames() []string {
	if x != nil {
		return x.Names
	}
	return nil
}

func (x *PathEdge) GetOutboundReach() int32 {
	if x != nil {
		return x.OutboundReach
	}
	return 0
}

func (x *PathEdge) GetInboundReach() int32 {
	if x != nil {
		return x.InboundReach
	}
	return 0
}

func (x *PathEdge) GetHeading() float32 {
	if x != nil {
		return x.Heading
	}
	return 0
}

// Output information about how the location object below is correlated to the graph or to the route etc
type Correlation struct {
	state                 protoimpl.MessageState `protogen:"open.v1"`
	Edges                 []*PathEdge            `protobuf:"bytes,1,rep,name=edges,proto3" json:"edges,omitempty"`
	FilteredEdges         []*PathEdge            `protobuf:"bytes,2,rep,name=filtered_edges,json=filteredEdges,proto3" json:"filtered_edges,omitempty"`
	OriginalIndex         uint32                 `protobuf:"varint,3,opt,name=original_index,json=originalIndex,proto3" json:"original_index,omitempty"`
	ProjectedLl           *LatLng                `protobuf:"bytes,4,opt,name=projected_ll,json=projectedLl,proto3" json:"projected_ll,omitempty"`
	LegShapeIndex         uint32                 `protobuf:"varint,5,opt,name=leg_shape_index,json=legShapeIndex,proto3" json:"leg_shape_index,omitempty"`
	DistanceFromLegOrigin float64                `protobuf:"fixed64,6,opt,name=distance_from_leg_origin,json=distanceFromLegOrigin,proto3" json:"distance_from_leg_origin,omitempty"`
	RouteIndex            uint32                 `protobuf:"varint,7,opt,name=route_index,json=routeIndex,proto3" json:"route_index,omitempty"`          // primarily for matchings index in osrm map matching
	WaypointIndex         uint32                 `protobuf:"varint,8,opt,name=waypoint_index,json=waypointIndex,proto3" json:"waypoint_index,omitempty"` // primarily for matched point index in osrm map matching
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *Correlation) Reset() {
	*x = Correlation{}
	mi := &file_common_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Correlation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Correlation) ProtoMessage() {}

func (x *Correlation) ProtoReflect() protoreflect.Message {
	mi := &file_common_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Correlation.ProtoReflect.Descriptor instead.
func (*Correlation) Descriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{5}
}

func (x *Correlation) GetEdges() []*PathEdge {
	if x != nil {
		return x.Edges
	}
	return nil
}

func (x *Correlation) GetFilteredEdges() []*PathEdge {
	if x != nil {
		return x.FilteredEdges
	}
	return nil
}

func (x *Correlation) GetOriginalIndex() uint32 {
	if x != nil {
		return x.OriginalIndex
	}
	return 0
}

func (x *Correlation) GetProjectedLl() *LatLng {
	if x != nil {
		return x.ProjectedLl
	}
	return nil
}

func (x *Correlation) GetLegShapeIndex() uint32 {
	if x != nil {
		return x.LegShapeIndex
	}
	return 0
}

func (x *Correlation) GetDistanceFromLegOrigin() float64 {
	if x != nil {
		return x.DistanceFromLegOrigin
	}
	return 0
}

func (x *Correlation) GetRouteIndex() uint32 {
	if x != nil {
		return x.RouteIndex
	}
	return 0
}

func (x *Correlation) GetWaypointIndex() uint32 {
	if x != nil {
		return x.WaypointIndex
	}
	return 0
}

type Location struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Ll    *LatLng                `protobuf:"bytes,1,opt,name=ll,proto3" json:"ll,omitempty"`
	Type  Location_Type          `protobuf:"varint,2,opt,name=type,proto3,enum=valhalla.Location_Type" json:"type,omitempty"` // [default = kBreak]
	// Types that are valid to be assigned to HasHeading:
	//
	//	*Location_Heading
	HasHeading   isLocation_HasHeading `protobuf_oneof:"has_heading"`
	Name         string                `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	Street       string                `protobuf:"bytes,5,opt,name=street,proto3" json:"street,omitempty"`
	DateTime     string                `protobuf:"bytes,12,opt,name=date_time,json=dateTime,proto3" json:"date_time,omitempty"`
	SideOfStreet Location_SideOfStreet `protobuf:"varint,13,opt,name=side_of_street,json=sideOfStreet,proto3,enum=valhalla.Location_SideOfStreet" json:"side_of_street,omitempty"`
	// Types that are valid to be assigned to HasHeadingTolerance:
	//
	//	*Location_HeadingTolerance
	HasHeadingTolerance isLocation_HasHeadingTolerance `protobuf_oneof:"has_heading_tolerance"`
	// Types that are valid to be assigned to HasNodeSnapTolerance:
	//
	//	*Location_NodeSnapTolerance
	HasNodeSnapTolerance isLocation_HasNodeSnapTolerance `protobuf_oneof:"has_node_snap_tolerance"`
	// Types that are valid to be assigned to HasMinimumReachability:
	//
	//	*Location_MinimumReachability
	HasMinimumReachability isLocation_HasMinimumReachability `protobuf_oneof:"has_minimum_reachability"`
	// Types that are valid to be assigned to HasRadius:
	//
	//	*Location_Radius
	HasRadius isLocation_HasRadius `protobuf_oneof:"has_radius"`
	// Types that are valid to be assigned to HasAccuracy:
	//
	//	*Location_Accuracy
	HasAccuracy isLocation_HasAccuracy `protobuf_oneof:"has_accuracy"`
	// Types that are valid to be assigned to HasTime:
	//
	//	*Location_Time
	HasTime               isLocation_HasTime     `protobuf_oneof:"has_time"`
	SkipRankingCandidates bool                   `protobuf:"varint,21,opt,name=skip_ranking_candidates,json=skipRankingCandidates,proto3" json:"skip_ranking_candidates,omitempty"`
	PreferredSide         Location_PreferredSide `protobuf:"varint,22,opt,name=preferred_side,json=preferredSide,proto3,enum=valhalla.Location_PreferredSide" json:"preferred_side,omitempty"`
	DisplayLl             *LatLng                `protobuf:"bytes,23,opt,name=display_ll,json=displayLl,proto3" json:"display_ll,omitempty"`
	// Types that are valid to be assigned to HasSearchCutoff:
	//
	//	*Location_SearchCutoff
	HasSearchCutoff isLocation_HasSearchCutoff `protobuf_oneof:"has_search_cutoff"`
	// Types that are valid to be assigned to HasStreetSideTolerance:
	//
	//	*Location_StreetSideTolerance
	HasStreetSideTolerance isLocation_HasStreetSideTolerance `protobuf_oneof:"has_street_side_tolerance"`
	SearchFilter           *SearchFilter                     `protobuf:"bytes,26,opt,name=search_filter,json=searchFilter,proto3" json:"search_filter,omitempty"`
	// Types that are valid to be assigned to HasStreetSideMaxDistance:
	//
	//	*Location_StreetSideMaxDistance
	HasStreetSideMaxDistance isLocation_HasStreetSideMaxDistance `protobuf_oneof:"has_street_side_max_distance"`
	// Types that are valid to be assigned to HasPreferredLayer:
	//
	//	*Location_PreferredLayer
	HasPreferredLayer isLocation_HasPreferredLayer `protobuf_oneof:"has_preferred_layer"`
	WaitingSecs       float32                      `protobuf:"fixed32,29,opt,name=waiting_secs,json=waitingSecs,proto3" json:"waiting_secs,omitempty"` // waiting period before a new leg starts, e.g. for servicing/loading goods
	// Types that are valid to be assigned to HasStreetSideCutoff:
	//
	//	*Location_StreetSideCutoff
	HasStreetSideCutoff isLocation_HasStreetSideCutoff `protobuf_oneof:"has_street_side_cutoff"`
	// This information will be ignored if provided in the request. Instead it will be filled in as the request is handled
	Correlation    *Correlation `protobuf:"bytes,90,opt,name=correlation,proto3" json:"correlation,omitempty"`
	TimeZoneOffset string       `protobuf:"bytes,91,opt,name=time_zone_offset,json=timeZoneOffset,proto3" json:"time_zone_offset,omitempty"`
	TimeZoneName   string       `protobuf:"bytes,92,opt,name=time_zone_name,json=timeZoneName,proto3" json:"time_zone_name,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *Location) Reset() {
	*x = Location{}
	mi := &file_common_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Location) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Location) ProtoMessage() {}

func (x *Location) ProtoReflect() protoreflect.Message {
	mi := &file_common_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Location.ProtoReflect.Descriptor instead.
func (*Location) Descriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{6}
}

func (x *Location) GetLl() *LatLng {
	if x != nil {
		return x.Ll
	}
	return nil
}

func (x *Location) GetType() Location_Type {
	if x != nil {
		return x.Type
	}
	return Location_kBreak
}

func (x *Location) GetHasHeading() isLocation_HasHeading {
	if x != nil {
		return x.HasHeading
	}
	return nil
}

func (x *Location) GetHeading() uint32 {
	if x != nil {
		if x, ok := x.HasHeading.(*Location_Heading); ok {
			return x.Heading
		}
	}
	return 0
}

func (x *Location) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Location) GetStreet() string {
	if x != nil {
		return x.Street
	}
	return ""
}

func (x *Location) GetDateTime() string {
	if x != nil {
		return x.DateTime
	}
	return ""
}

func (x *Location) GetSideOfStreet() Location_SideOfStreet {
	if x != nil {
		return x.SideOfStreet
	}
	return Location_kNone
}

func (x *Location) GetHasHeadingTolerance() isLocation_HasHeadingTolerance {
	if x != nil {
		return x.HasHeadingTolerance
	}
	return nil
}

func (x *Location) GetHeadingTolerance() uint32 {
	if x != nil {
		if x, ok := x.HasHeadingTolerance.(*Location_HeadingTolerance); ok {
			return x.HeadingTolerance
		}
	}
	return 0
}

func (x *Location) GetHasNodeSnapTolerance() isLocation_HasNodeSnapTolerance {
	if x != nil {
		return x.HasNodeSnapTolerance
	}
	return nil
}

func (x *Location) GetNodeSnapTolerance() uint32 {
	if x != nil {
		if x, ok := x.HasNodeSnapTolerance.(*Location_NodeSnapTolerance); ok {
			return x.NodeSnapTolerance
		}
	}
	return 0
}

func (x *Location) GetHasMinimumReachability() isLocation_HasMinimumReachability {
	if x != nil {
		return x.HasMinimumReachability
	}
	return nil
}

func (x *Location) GetMinimumReachability() uint32 {
	if x != nil {
		if x, ok := x.HasMinimumReachability.(*Location_MinimumReachability); ok {
			return x.MinimumReachability
		}
	}
	return 0
}

func (x *Location) GetHasRadius() isLocation_HasRadius {
	if x != nil {
		return x.HasRadius
	}
	return nil
}

func (x *Location) GetRadius() uint32 {
	if x != nil {
		if x, ok := x.HasRadius.(*Location_Radius); ok {
			return x.Radius
		}
	}
	return 0
}

func (x *Location) GetHasAccuracy() isLocation_HasAccuracy {
	if x != nil {
		return x.HasAccuracy
	}
	return nil
}

func (x *Location) GetAccuracy() uint32 {
	if x != nil {
		if x, ok := x.HasAccuracy.(*Location_Accuracy); ok {
			return x.Accuracy
		}
	}
	return 0
}

func (x *Location) GetHasTime() isLocation_HasTime {
	if x != nil {
		return x.HasTime
	}
	return nil
}

func (x *Location) GetTime() float64 {
	if x != nil {
		if x, ok := x.HasTime.(*Location_Time); ok {
			return x.Time
		}
	}
	return 0
}

func (x *Location) GetSkipRankingCandidates() bool {
	if x != nil {
		return x.SkipRankingCandidates
	}
	return false
}

func (x *Location) GetPreferredSide() Location_PreferredSide {
	if x != nil {
		return x.PreferredSide
	}
	return Location_either
}

func (x *Location) GetDisplayLl() *LatLng {
	if x != nil {
		return x.DisplayLl
	}
	return nil
}

func (x *Location) GetHasSearchCutoff() isLocation_HasSearchCutoff {
	if x != nil {
		return x.HasSearchCutoff
	}
	return nil
}

func (x *Location) GetSearchCutoff() uint32 {
	if x != nil {
		if x, ok := x.HasSearchCutoff.(*Location_SearchCutoff); ok {
			return x.SearchCutoff
		}
	}
	return 0
}

func (x *Location) GetHasStreetSideTolerance() isLocation_HasStreetSideTolerance {
	if x != nil {
		return x.HasStreetSideTolerance
	}
	return nil
}

func (x *Location) GetStreetSideTolerance() uint32 {
	if x != nil {
		if x, ok := x.HasStreetSideTolerance.(*Location_StreetSideTolerance); ok {
			return x.StreetSideTolerance
		}
	}
	return 0
}

func (x *Location) GetSearchFilter() *SearchFilter {
	if x != nil {
		return x.SearchFilter
	}
	return nil
}

func (x *Location) GetHasStreetSideMaxDistance() isLocation_HasStreetSideMaxDistance {
	if x != nil {
		return x.HasStreetSideMaxDistance
	}
	return nil
}

func (x *Location) GetStreetSideMaxDistance() uint32 {
	if x != nil {
		if x, ok := x.HasStreetSideMaxDistance.(*Location_StreetSideMaxDistance); ok {
			return x.StreetSideMaxDistance
		}
	}
	return 0
}

func (x *Location) GetHasPreferredLayer() isLocation_HasPreferredLayer {
	if x != nil {
		return x.HasPreferredLayer
	}
	return nil
}

func (x *Location) GetPreferredLayer() int32 {
	if x != nil {
		if x, ok := x.HasPreferredLayer.(*Location_PreferredLayer); ok {
			return x.PreferredLayer
		}
	}
	return 0
}

func (x *Location) GetWaitingSecs() float32 {
	if x != nil {
		return x.WaitingSecs
	}
	return 0
}

func (x *Location) GetHasStreetSideCutoff() isLocation_HasStreetSideCutoff {
	if x != nil {
		return x.HasStreetSideCutoff
	}
	return nil
}

func (x *Location) GetStreetSideCutoff() RoadClass {
	if x != nil {
		if x, ok := x.HasStreetSideCutoff.(*Location_StreetSideCutoff); ok {
			return x.StreetSideCutoff
		}
	}
	return RoadClass_kMotorway
}

func (x *Location) GetCorrelation() *Correlation {
	if x != nil {
		return x.Correlation
	}
	return nil
}

func (x *Location) GetTimeZoneOffset() string {
	if x != nil {
		return x.TimeZoneOffset
	}
	return ""
}

func (x *Location) GetTimeZoneName() string {
	if x != nil {
		return x.TimeZoneName
	}
	return ""
}

type isLocation_HasHeading interface {
	isLocation_HasHeading()
}

type Location_Heading struct {
	Heading uint32 `protobuf:"varint,3,opt,name=heading,proto3,oneof"` // 0-359
}

func (*Location_Heading) isLocation_HasHeading() {}

type isLocation_HasHeadingTolerance interface {
	isLocation_HasHeadingTolerance()
}

type Location_HeadingTolerance struct {
	HeadingTolerance uint32 `protobuf:"varint,14,opt,name=heading_tolerance,json=headingTolerance,proto3,oneof"`
}

func (*Location_HeadingTolerance) isLocation_HasHeadingTolerance() {}

type isLocation_HasNodeSnapTolerance interface {
	isLocation_HasNodeSnapTolerance()
}

type Location_NodeSnapTolerance struct {
	NodeSnapTolerance uint32 `protobuf:"varint,15,opt,name=node_snap_tolerance,json=nodeSnapTolerance,proto3,oneof"`
}

func (*Location_NodeSnapTolerance) isLocation_HasNodeSnapTolerance() {}

type isLocation_HasMinimumReachability interface {
	isLocation_HasMinimumReachability()
}

type Location_MinimumReachability struct {
	MinimumReachability uint32 `protobuf:"varint,17,opt,name=minimum_reachability,json=minimumReachability,proto3,oneof"`
}

func (*Location_MinimumReachability) isLocation_HasMinimumReachability() {}

type isLocation_HasRadius interface {
	isLocation_HasRadius()
}

type Location_Radius struct {
	Radius uint32 `protobuf:"varint,18,opt,name=radius,proto3,oneof"`
}

func (*Location_Radius) isLocation_HasRadius() {}

type isLocation_HasAccuracy interface {
	isLocation_HasAccuracy()
}

type Location_Accuracy struct {
	Accuracy uint32 `protobuf:"varint,19,opt,name=accuracy,proto3,oneof"`
}

func (*Location_Accuracy) isLocation_HasAccuracy() {}

type isLocation_HasTime interface {
	isLocation_HasTime()
}

type Location_Time struct {
	Time float64 `protobuf:"fixed64,20,opt,name=time,proto3,oneof"`
}

func (*Location_Time) isLocation_HasTime() {}

type isLocation_HasSearchCutoff interface {
	isLocation_HasSearchCutoff()
}

type Location_SearchCutoff struct {
	SearchCutoff uint32 `protobuf:"varint,24,opt,name=search_cutoff,json=searchCutoff,proto3,oneof"`
}

func (*Location_SearchCutoff) isLocation_HasSearchCutoff() {}

type isLocation_HasStreetSideTolerance interface {
	isLocation_HasStreetSideTolerance()
}

type Location_StreetSideTolerance struct {
	StreetSideTolerance uint32 `protobuf:"varint,25,opt,name=street_side_tolerance,json=streetSideTolerance,proto3,oneof"`
}

func (*Location_StreetSideTolerance) isLocation_HasStreetSideTolerance() {}

type isLocation_HasStreetSideMaxDistance interface {
	isLocation_HasStreetSideMaxDistance()
}

type Location_StreetSideMaxDistance struct {
	StreetSideMaxDistance uint32 `protobuf:"varint,27,opt,name=street_side_max_distance,json=streetSideMaxDistance,proto3,oneof"`
}

func (*Location_StreetSideMaxDistance) isLocation_HasStreetSideMaxDistance() {}

type isLocation_HasPreferredLayer interface {
	isLocation_HasPreferredLayer()
}

type Location_PreferredLayer struct {
	PreferredLayer int32 `protobuf:"varint,28,opt,name=preferred_layer,json=preferredLayer,proto3,oneof"`
}

func (*Location_PreferredLayer) isLocation_HasPreferredLayer() {}

type isLocation_HasStreetSideCutoff interface {
	isLocation_HasStreetSideCutoff()
}

type Location_StreetSideCutoff struct {
	StreetSideCutoff RoadClass `protobuf:"varint,30,opt,name=street_side_cutoff,json=streetSideCutoff,proto3,enum=valhalla.RoadClass,oneof"`
}

func (*Location_StreetSideCutoff) isLocation_HasStreetSideCutoff() {}

type TransitEgressInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	OnestopId     string                 `protobuf:"bytes,1,opt,name=onestop_id,json=onestopId,proto3" json:"onestop_id,omitempty"` // Unique ID
	Name          string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`                            // The name of the egress
	Ll            *LatLng                `protobuf:"bytes,3,opt,name=ll,proto3" json:"ll,omitempty"`                                // Latitude, longitude of the egress
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TransitEgressInfo) Reset() {
	*x = TransitEgressInfo{}
	mi := &file_common_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TransitEgressInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TransitEgressInfo) ProtoMessage() {}

func (x *TransitEgressInfo) ProtoReflect() protoreflect.Message {
	mi := &file_common_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TransitEgressInfo.ProtoReflect.Descriptor instead.
func (*TransitEgressInfo) Descriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{7}
}

func (x *TransitEgressInfo) GetOnestopId() string {
	if x != nil {
		return x.OnestopId
	}
	return ""
}

func (x *TransitEgressInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *TransitEgressInfo) GetLl() *LatLng {
	if x != nil {
		return x.Ll
	}
	return nil
}

type TransitStationInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	OnestopId     string                 `protobuf:"bytes,1,opt,name=onestop_id,json=onestopId,proto3" json:"onestop_id,omitempty"` // Unique ID
	Name          string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`                            // The name of the station
	Ll            *LatLng                `protobuf:"bytes,3,opt,name=ll,proto3" json:"ll,omitempty"`                                // Latitude, longitude of the station
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TransitStationInfo) Reset() {
	*x = TransitStationInfo{}
	mi := &file_common_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TransitStationInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TransitStationInfo) ProtoMessage() {}

func (x *TransitStationInfo) ProtoReflect() protoreflect.Message {
	mi := &file_common_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TransitStationInfo.ProtoReflect.Descriptor instead.
func (*TransitStationInfo) Descriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{8}
}

func (x *TransitStationInfo) GetOnestopId() string {
	if x != nil {
		return x.OnestopId
	}
	return ""
}

func (x *TransitStationInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *TransitStationInfo) GetLl() *LatLng {
	if x != nil {
		return x.Ll
	}
	return nil
}

type BikeShareStationInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Ref           string                 `protobuf:"bytes,2,opt,name=ref,proto3" json:"ref,omitempty"`
	Capacity      uint32                 `protobuf:"varint,3,opt,name=capacity,proto3" json:"capacity,omitempty"`
	Network       string                 `protobuf:"bytes,4,opt,name=network,proto3" json:"network,omitempty"`
	Operator      string                 `protobuf:"bytes,5,opt,name=operator,proto3" json:"operator,omitempty"`
	RentCost      float32                `protobuf:"fixed32,6,opt,name=rent_cost,json=rentCost,proto3" json:"rent_cost,omitempty"`
	ReturnCost    float32                `protobuf:"fixed32,7,opt,name=return_cost,json=returnCost,proto3" json:"return_cost,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BikeShareStationInfo) Reset() {
	*x = BikeShareStationInfo{}
	mi := &file_common_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BikeShareStationInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BikeShareStationInfo) ProtoMessage() {}

func (x *BikeShareStationInfo) ProtoReflect() protoreflect.Message {
	mi := &file_common_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BikeShareStationInfo.ProtoReflect.Descriptor instead.
func (*BikeShareStationInfo) Descriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{9}
}

func (x *BikeShareStationInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *BikeShareStationInfo) GetRef() string {
	if x != nil {
		return x.Ref
	}
	return ""
}

func (x *BikeShareStationInfo) GetCapacity() uint32 {
	if x != nil {
		return x.Capacity
	}
	return 0
}

func (x *BikeShareStationInfo) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

func (x *BikeShareStationInfo) GetOperator() string {
	if x != nil {
		return x.Operator
	}
	return ""
}

func (x *BikeShareStationInfo) GetRentCost() float32 {
	if x != nil {
		return x.RentCost
	}
	return 0
}

func (x *BikeShareStationInfo) GetReturnCost() float32 {
	if x != nil {
		return x.ReturnCost
	}
	return 0
}

type TransitPlatformInfo struct {
	state             protoimpl.MessageState   `protogen:"open.v1"`
	Type              TransitPlatformInfo_Type `protobuf:"varint,1,opt,name=type,proto3,enum=valhalla.TransitPlatformInfo_Type" json:"type,omitempty"`              // The type of stop (station or simple stop)
	OnestopId         string                   `protobuf:"bytes,2,opt,name=onestop_id,json=onestopId,proto3" json:"onestop_id,omitempty"`                           // Unique ID
	Name              string                   `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`                                                      // The name of the platform
	ArrivalDateTime   string                   `protobuf:"bytes,4,opt,name=arrival_date_time,json=arrivalDateTime,proto3" json:"arrival_date_time,omitempty"`       // ISO 8601 arrival date/time YYYY-MM-DDThh:mm
	DepartureDateTime string                   `protobuf:"bytes,5,opt,name=departure_date_time,json=departureDateTime,proto3" json:"departure_date_time,omitempty"` // ISO 8601 departure date/time YYYY-MM-DDThh:mm
	AssumedSchedule   bool                     `protobuf:"varint,6,opt,name=assumed_schedule,json=assumedSchedule,proto3" json:"assumed_schedule,omitempty"`        // true if the times are based on an assumed schedule
	Ll                *LatLng                  `protobuf:"bytes,7,opt,name=ll,proto3" json:"ll,omitempty"`                                                          // Latitude, longitude of the transit stop
	StationOnestopId  string                   `protobuf:"bytes,8,opt,name=station_onestop_id,json=stationOnestopId,proto3" json:"station_onestop_id,omitempty"`    // Unique station ID
	StationName       string                   `protobuf:"bytes,9,opt,name=station_name,json=stationName,proto3" json:"station_name,omitempty"`                     // The station name of the platform
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *TransitPlatformInfo) Reset() {
	*x = TransitPlatformInfo{}
	mi := &file_common_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TransitPlatformInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TransitPlatformInfo) ProtoMessage() {}

func (x *TransitPlatformInfo) ProtoReflect() protoreflect.Message {
	mi := &file_common_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TransitPlatformInfo.ProtoReflect.Descriptor instead.
func (*TransitPlatformInfo) Descriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{10}
}

func (x *TransitPlatformInfo) GetType() TransitPlatformInfo_Type {
	if x != nil {
		return x.Type
	}
	return TransitPlatformInfo_kStop
}

func (x *TransitPlatformInfo) GetOnestopId() string {
	if x != nil {
		return x.OnestopId
	}
	return ""
}

func (x *TransitPlatformInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *TransitPlatformInfo) GetArrivalDateTime() string {
	if x != nil {
		return x.ArrivalDateTime
	}
	return ""
}

func (x *TransitPlatformInfo) GetDepartureDateTime() string {
	if x != nil {
		return x.DepartureDateTime
	}
	return ""
}

func (x *TransitPlatformInfo) GetAssumedSchedule() bool {
	if x != nil {
		return x.AssumedSchedule
	}
	return false
}

func (x *TransitPlatformInfo) GetLl() *LatLng {
	if x != nil {
		return x.Ll
	}
	return nil
}

func (x *TransitPlatformInfo) GetStationOnestopId() string {
	if x != nil {
		return x.StationOnestopId
	}
	return ""
}

func (x *TransitPlatformInfo) GetStationName() string {
	if x != nil {
		return x.StationName
	}
	return ""
}

type TransitRouteInfo struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	OnestopId         string                 `protobuf:"bytes,1,opt,name=onestop_id,json=onestopId,proto3" json:"onestop_id,omitempty"`
	BlockId           uint32                 `protobuf:"varint,2,opt,name=block_id,json=blockId,proto3" json:"block_id,omitempty"`
	TripId            uint32                 `protobuf:"varint,3,opt,name=trip_id,json=tripId,proto3" json:"trip_id,omitempty"`
	ShortName         string                 `protobuf:"bytes,4,opt,name=short_name,json=shortName,proto3" json:"short_name,omitempty"`
	LongName          string                 `protobuf:"bytes,5,opt,name=long_name,json=longName,proto3" json:"long_name,omitempty"`
	Headsign          string                 `protobuf:"bytes,6,opt,name=headsign,proto3" json:"headsign,omitempty"`
	Color             uint32                 `protobuf:"varint,7,opt,name=color,proto3" json:"color,omitempty"`
	TextColor         uint32                 `protobuf:"varint,8,opt,name=text_color,json=textColor,proto3" json:"text_color,omitempty"`
	Description       string                 `protobuf:"bytes,9,opt,name=description,proto3" json:"description,omitempty"`
	OperatorOnestopId string                 `protobuf:"bytes,10,opt,name=operator_onestop_id,json=operatorOnestopId,proto3" json:"operator_onestop_id,omitempty"`
	OperatorName      string                 `protobuf:"bytes,11,opt,name=operator_name,json=operatorName,proto3" json:"operator_name,omitempty"`
	OperatorUrl       string                 `protobuf:"bytes,12,opt,name=operator_url,json=operatorUrl,proto3" json:"operator_url,omitempty"`
	TransitStops      []*TransitPlatformInfo `protobuf:"bytes,13,rep,name=transit_stops,json=transitStops,proto3" json:"transit_stops,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *TransitRouteInfo) Reset() {
	*x = TransitRouteInfo{}
	mi := &file_common_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TransitRouteInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TransitRouteInfo) ProtoMessage() {}

func (x *TransitRouteInfo) ProtoReflect() protoreflect.Message {
	mi := &file_common_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TransitRouteInfo.ProtoReflect.Descriptor instead.
func (*TransitRouteInfo) Descriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{11}
}

func (x *TransitRouteInfo) GetOnestopId() string {
	if x != nil {
		return x.OnestopId
	}
	return ""
}

func (x *TransitRouteInfo) GetBlockId() uint32 {
	if x != nil {
		return x.BlockId
	}
	return 0
}

func (x *TransitRouteInfo) GetTripId() uint32 {
	if x != nil {
		return x.TripId
	}
	return 0
}

func (x *TransitRouteInfo) GetShortName() string {
	if x != nil {
		return x.ShortName
	}
	return ""
}

func (x *TransitRouteInfo) GetLongName() string {
	if x != nil {
		return x.LongName
	}
	return ""
}

func (x *TransitRouteInfo) GetHeadsign() string {
	if x != nil {
		return x.Headsign
	}
	return ""
}

func (x *TransitRouteInfo) GetColor() uint32 {
	if x != nil {
		return x.Color
	}
	return 0
}

func (x *TransitRouteInfo) GetTextColor() uint32 {
	if x != nil {
		return x.TextColor
	}
	return 0
}

func (x *TransitRouteInfo) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *TransitRouteInfo) GetOperatorOnestopId() string {
	if x != nil {
		return x.OperatorOnestopId
	}
	return ""
}

func (x *TransitRouteInfo) GetOperatorName() string {
	if x != nil {
		return x.OperatorName
	}
	return ""
}

func (x *TransitRouteInfo) GetOperatorUrl() string {
	if x != nil {
		return x.OperatorUrl
	}
	return ""
}

func (x *TransitRouteInfo) GetTransitStops() []*TransitPlatformInfo {
	if x != nil {
		return x.TransitStops
	}
	return nil
}

type Pronunciation struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Alphabet Pronunciation_Alphabet `protobuf:"varint,1,opt,name=alphabet,proto3,enum=valhalla.Pronunciation_Alphabet" json:"alphabet,omitempty"`
	Value    string                 `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Pronunciation) Reset() {
	*x = Pronunciation{}
	mi := &file_common_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Pronunciation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Pronunciation) ProtoMessage() {}

func (x *Pronunciation) ProtoReflect() protoreflect.Message {
	mi := &file_common_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Pronunciation.ProtoReflect.Descriptor instead.
func (*Pronunciation) Descriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{12}
}

func (x *Pronunciation) GetAlphabet() Pronunciation_Alphabet {
	if x != nil {
		return x.Alphabet
	}
	return Pronunciation_kNone
}

func (x *Pronunciation) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

type StreetName struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         string                 `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`                                         // The actual street name value, examples: I 95 North or Derry Street
	IsRouteNumber bool                   `protobuf:"varint,2,opt,name=is_route_number,json=isRouteNumber,proto3" json:"is_route_number,omitempty"` // true if the street name is a reference route number such as: I 81 South or US 322 West
	Pronunciation *Pronunciation         `protobuf:"bytes,3,opt,name=pronunciation,proto3" json:"pronunciation,omitempty"`                         // The pronunciation associated with this street name
	LanguageTag   LanguageTag            `protobuf:"varint,4,opt,name=language_tag,json=languageTag,proto3,enum=valhalla.LanguageTag" json:"language_tag,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreetName) Reset() {
	*x = StreetName{}
	mi := &file_common_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreetName) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreetName) ProtoMessage() {}

func (x *StreetName) ProtoReflect() protoreflect.Message {
	mi := &file_common_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreetName.ProtoReflect.Descriptor instead.
func (*StreetName) Descriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{13}
}

func (x *StreetName) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

func (x *StreetName) GetIsRouteNumber() bool {
	if x != nil {
		return x.IsRouteNumber
	}
	return false
}

func (x *StreetName) GetPronunciation() *Pronunciation {
	if x != nil {
		return x.Pronunciation
	}
	return nil
}

func (x *StreetName) GetLanguageTag() LanguageTag {
	if x != nil {
		return x.LanguageTag
	}
	return LanguageTag_kUnspecified
}

type TurnLane struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	DirectionsMask  uint32         `protobuf:"varint,1,opt,name=directions_mask,json=directionsMask,proto3" json:"directions_mask,omitempty"`
	State           TurnLane_State `protobuf:"varint,2,opt,name=state,proto3,enum=valhalla.TurnLane_State" json:"state,omitempty"`
	ActiveDirection uint32         `protobuf:"varint,3,opt,name=active_direction,json=activeDirection,proto3" json:"active_direction,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *TurnLane) Reset() {
	*x = TurnLane{}
	mi := &file_common_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TurnLane) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TurnLane) ProtoMessage() {}

func (x *TurnLane) ProtoReflect() protoreflect.Message {
	mi := &file_common_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TurnLane.ProtoReflect.Descriptor instead.
func (*TurnLane) Descriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{14}
}

func (x *TurnLane) GetDirectionsMask() uint32 {
	if x != nil {
		return x.DirectionsMask
	}
	return 0
}

func (x *TurnLane) GetState() TurnLane_State {
	if x != nil {
		return x.State
	}
	return TurnLane_kInvalid
}

func (x *TurnLane) GetActiveDirection() uint32 {
	if x != nil {
		return x.ActiveDirection
	}
	return 0
}

type TaggedValue struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         []byte                 `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`                               // The actual tagged name value, examples: Ted Williams Tunnel
	Type          TaggedValue_Type       `protobuf:"varint,2,opt,name=type,proto3,enum=valhalla.TaggedValue_Type" json:"type,omitempty"` // The type of tagged name (tunnel or bridge)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TaggedValue) Reset() {
	*x = TaggedValue{}
	mi := &file_common_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TaggedValue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TaggedValue) ProtoMessage() {}

func (x *TaggedValue) ProtoReflect() protoreflect.Message {
	mi := &file_common_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TaggedValue.ProtoReflect.Descriptor instead.
func (*TaggedValue) Descriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{15}
}

func (x *TaggedValue) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *TaggedValue) GetType() TaggedValue_Type {
	if x != nil {
		return x.Type
	}
	return TaggedValue_kNone
}

type Summary struct {
	state               protoimpl.MessageState `protogen:"open.v1"`
	Length              float32                `protobuf:"fixed32,1,opt,name=length,proto3" json:"length,omitempty"`                                                       // kilometers or miles based on units
	Time                float64                `protobuf:"fixed64,2,opt,name=time,proto3" json:"time,omitempty"`                                                           // seconds
	Bbox                *BoundingBox           `protobuf:"bytes,3,opt,name=bbox,proto3" json:"bbox,omitempty"`                                                             // Bounding box of the shape
	HasTimeRestrictions bool                   `protobuf:"varint,4,opt,name=has_time_restrictions,json=hasTimeRestrictions,proto3" json:"has_time_restrictions,omitempty"` // Does the route contain any time restrictions?
	HasToll             bool                   `protobuf:"varint,5,opt,name=has_toll,json=hasToll,proto3" json:"has_toll,omitempty"`
	HasFerry            bool                   `protobuf:"varint,6,opt,name=has_ferry,json=hasFerry,proto3" json:"has_ferry,omitempty"`
	HasHighway          bool                   `protobuf:"varint,7,opt,name=has_highway,json=hasHighway,proto3" json:"has_highway,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *Summary) Reset() {
	*x = Summary{}
	mi := &file_common_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Summary) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Summary) ProtoMessage() {}

func (x *Summary) ProtoReflect() protoreflect.Message {
	mi := &file_common_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Summary.ProtoReflect.Descriptor instead.
func (*Summary) Descriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{16}
}

func (x *Summary) GetLength() float32 {
	if x != nil {
		return x.Length
	}
	return 0
}

func (x *Summary) GetTime() float64 {
	if x != nil {
		return x.Time
	}
	return 0
}

func (x *Summary) GetBbox() *BoundingBox {
	if x != nil {
		return x.Bbox
	}
	return nil
}

func (x *Summary) GetHasTimeRestrictions() bool {
	if x != nil {
		return x.HasTimeRestrictions
	}
	return false
}

func (x *Summary) GetHasToll() bool {
	if x != nil {
		return x.HasToll
	}
	return false
}

func (x *Summary) GetHasFerry() bool {
	if x != nil {
		return x.HasFerry
	}
	return false
}

func (x *Summary) GetHasHighway() bool {
	if x != nil {
		return x.HasHighway
	}
	return false
}

type LevelChange struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ShapeIndex    uint32                 `protobuf:"varint,1,opt,name=shape_index,json=shapeIndex,proto3" json:"shape_index,omitempty"`
	Level         float32                `protobuf:"fixed32,2,opt,name=level,proto3" json:"level,omitempty"`
	Precision     uint32                 `protobuf:"varint,3,opt,name=precision,proto3" json:"precision,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LevelChange) Reset() {
	*x = LevelChange{}
	mi := &file_common_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LevelChange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LevelChange) ProtoMessage() {}

func (x *LevelChange) ProtoReflect() protoreflect.Message {
	mi := &file_common_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LevelChange.ProtoReflect.Descriptor instead.
func (*LevelChange) Descriptor() ([]byte, []int) {
	return file_common_proto_rawDescGZIP(), []int{17}
}

func (x *LevelChange) GetShapeIndex() uint32 {
	if x != nil {
		return x.ShapeIndex
	}
	return 0
}

func (x *LevelChange) GetLevel() float32 {
	if x != nil {
		return x.Level
	}
	return 0
}

func (x *LevelChange) GetPrecision() uint32 {
	if x != nil {
		return x.Precision
	}
	return 0
}

var File_common_proto protoreflect.FileDescriptor

const file_common_proto_rawDesc = "" +
	"\n" +
	"\fcommon.proto\x12\bvalhalla\"F\n" +
	"\x06LatLng\x12\x12\n" +
	"\x03lat\x18\x01 \x01(\x01H\x00R\x03lat\x12\x12\n" +
	"\x03lng\x18\x02 \x01(\x01H\x01R\x03lngB\t\n" +
	"\ahas_latB\t\n" +
	"\ahas_lng\"\xc1\x03\n" +
	"\rRouteLandmark\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x120\n" +
	"\x04type\x18\x02 \x01(\x0e2\x1c.valhalla.RouteLandmark.TypeR\x04type\x12)\n" +
	"\alat_lng\x18\x03 \x01(\v2\x10.valhalla.LatLngR\x06latLng\x12\x1a\n" +
	"\bdistance\x18\x04 \x01(\x01R\bdistance\x12\x14\n" +
	"\x05right\x18\x05 \x01(\bR\x05right\"\x8c\x02\n" +
	"\x04Type\x12\v\n" +
	"\akUnused\x10\x00\x12\t\n" +
	"\x05kFuel\x10\x01\x12\x0f\n" +
	"\vkPostOffice\x10\x02\x12\v\n" +
	"\akPolice\x10\x03\x12\x10\n" +
	"\fkFireStation\x10\x04\x12\f\n" +
	"\bkCarWash\x10\x05\x12\x0f\n" +
	"\vkRestaurant\x10\x06\x12\r\n" +
	"\tkFastFood\x10\a\x12\t\n" +
	"\x05kCafe\x10\b\x12\t\n" +
	"\x05kBank\x10\t\x12\r\n" +
	"\tkPharmacy\x10\n" +
	"\x12\x11\n" +
	"\rkKindergarten\x10\v\x12\b\n" +
	"\x04kBar\x10\f\x12\r\n" +
	"\tkHospital\x10\r\x12\b\n" +
	"\x04kPub\x10\x0e\x12\v\n" +
	"\akClinic\x10\x0f\x12\f\n" +
	"\bkTheatre\x10\x10\x12\v\n" +
	"\akCinema\x10\x11\x12\v\n" +
	"\akCasino\x10\x12\"_\n" +
	"\vBoundingBox\x12'\n" +
	"\x06min_ll\x18\x01 \x01(\v2\x10.valhalla.LatLngR\x05minLl\x12'\n" +
	"\x06max_ll\x18\x02 \x01(\v2\x10.valhalla.LatLngR\x05maxLl\"\xd7\x03\n" +
	"\fSearchFilter\x12;\n" +
	"\x0emin_road_class\x18\x01 \x01(\x0e2\x13.valhalla.RoadClassH\x00R\fminRoadClass\x12;\n" +
	"\x0emax_road_class\x18\x02 \x01(\x0e2\x13.valhalla.RoadClassH\x01R\fmaxRoadClass\x12%\n" +
	"\x0eexclude_tunnel\x18\x03 \x01(\bR\rexcludeTunnel\x12%\n" +
	"\x0eexclude_bridge\x18\x04 \x01(\bR\rexcludeBridge\x12!\n" +
	"\fexclude_ramp\x18\x05 \x01(\bR\vexcludeRamp\x12+\n" +
	"\x10exclude_closures\x18\x06 \x01(\bH\x02R\x0fexcludeClosures\x12!\n" +
	"\fexclude_toll\x18\a \x01(\bR\vexcludeToll\x12#\n" +
	"\rexclude_ferry\x18\b \x01(\bR\fexcludeFerry\x12\x16\n" +
	"\x05level\x18\t \x01(\x02H\x03R\x05levelB\x14\n" +
	"\x12has_min_road_classB\x14\n" +
	"\x12has_max_road_classB\x16\n" +
	"\x14has_exclude_closuresB\v\n" +
	"\thas_level\"\x85\x03\n" +
	"\bPathEdge\x12\x19\n" +
	"\bgraph_id\x18\x01 \x01(\x04R\agraphId\x12#\n" +
	"\rpercent_along\x18\x02 \x01(\x01R\fpercentAlong\x12 \n" +
	"\x02ll\x18\x03 \x01(\v2\x10.valhalla.LatLngR\x02ll\x12E\n" +
	"\x0eside_of_street\x18\x04 \x01(\x0e2\x1f.valhalla.Location.SideOfStreetR\fsideOfStreet\x12\x1a\n" +
	"\bdistance\x18\x05 \x01(\x01R\bdistance\x12\x1d\n" +
	"\n" +
	"begin_node\x18\a \x01(\bR\tbeginNode\x12\x19\n" +
	"\bend_node\x18\b \x01(\bR\aendNode\x12\x14\n" +
	"\x05names\x18\n" +
	" \x03(\tR\x05names\x12%\n" +
	"\x0eoutbound_reach\x18\v \x01(\x05R\routboundReach\x12#\n" +
	"\rinbound_reach\x18\f \x01(\x05R\finboundReach\x12\x18\n" +
	"\aheading\x18\r \x01(\x02R\aheading\"\xf7\x02\n" +
	"\vCorrelation\x12(\n" +
	"\x05edges\x18\x01 \x03(\v2\x12.valhalla.PathEdgeR\x05edges\x129\n" +
	"\x0efiltered_edges\x18\x02 \x03(\v2\x12.valhalla.PathEdgeR\rfilteredEdges\x12%\n" +
	"\x0eoriginal_index\x18\x03 \x01(\rR\roriginalIndex\x123\n" +
	"\fprojected_ll\x18\x04 \x01(\v2\x10.valhalla.LatLngR\vprojectedLl\x12&\n" +
	"\x0fleg_shape_index\x18\x05 \x01(\rR\rlegShapeIndex\x127\n" +
	"\x18distance_from_leg_origin\x18\x06 \x01(\x01R\x15distanceFromLegOrigin\x12\x1f\n" +
	"\vroute_index\x18\a \x01(\rR\n" +
	"routeIndex\x12%\n" +
	"\x0ewaypoint_index\x18\b \x01(\rR\rwaypointIndex\"\xbe\f\n" +
	"\bLocation\x12 \n" +
	"\x02ll\x18\x01 \x01(\v2\x10.valhalla.LatLngR\x02ll\x12+\n" +
	"\x04type\x18\x02 \x01(\x0e2\x17.valhalla.Location.TypeR\x04type\x12\x1a\n" +
	"\aheading\x18\x03 \x01(\rH\x00R\aheading\x12\x12\n" +
	"\x04name\x18\x04 \x01(\tR\x04name\x12\x16\n" +
	"\x06street\x18\x05 \x01(\tR\x06street\x12\x1b\n" +
	"\tdate_time\x18\f \x01(\tR\bdateTime\x12E\n" +
	"\x0eside_of_street\x18\r \x01(\x0e2\x1f.valhalla.Location.SideOfStreetR\fsideOfStreet\x12-\n" +
	"\x11heading_tolerance\x18\x0e \x01(\rH\x01R\x10headingTolerance\x120\n" +
	"\x13node_snap_tolerance\x18\x0f \x01(\rH\x02R\x11nodeSnapTolerance\x123\n" +
	"\x14minimum_reachability\x18\x11 \x01(\rH\x03R\x13minimumReachability\x12\x18\n" +
	"\x06radius\x18\x12 \x01(\rH\x04R\x06radius\x12\x1c\n" +
	"\baccuracy\x18\x13 \x01(\rH\x05R\baccuracy\x12\x14\n" +
	"\x04time\x18\x14 \x01(\x01H\x06R\x04time\x126\n" +
	"\x17skip_ranking_candidates\x18\x15 \x01(\bR\x15skipRankingCandidates\x12G\n" +
	"\x0epreferred_side\x18\x16 \x01(\x0e2 .valhalla.Location.PreferredSideR\rpreferredSide\x12/\n" +
	"\n" +
	"display_ll\x18\x17 \x01(\v2\x10.valhalla.LatLngR\tdisplayLl\x12%\n" +
	"\rsearch_cutoff\x18\x18 \x01(\rH\aR\fsearchCutoff\x124\n" +
	"\x15street_side_tolerance\x18\x19 \x01(\rH\bR\x13streetSideTolerance\x12;\n" +
	"\rsearch_filter\x18\x1a \x01(\v2\x16.valhalla.SearchFilterR\fsearchFilter\x129\n" +
	"\x18street_side_max_distance\x18\x1b \x01(\rH\tR\x15streetSideMaxDistance\x12)\n" +
	"\x0fpreferred_layer\x18\x1c \x01(\x05H\n" +
	"R\x0epreferredLayer\x12!\n" +
	"\fwaiting_secs\x18\x1d \x01(\x02R\vwaitingSecs\x12C\n" +
	"\x12street_side_cutoff\x18\x1e \x01(\x0e2\x13.valhalla.RoadClassH\vR\x10streetSideCutoff\x127\n" +
	"\vcorrelation\x18Z \x01(\v2\x15.valhalla.CorrelationR\vcorrelation\x12(\n" +
	"\x10time_zone_offset\x18[ \x01(\tR\x0etimeZoneOffset\x12$\n" +
	"\x0etime_zone_name\x18\\ \x01(\tR\ftimeZoneName\"=\n" +
	"\x04Type\x12\n" +
	"\n" +
	"\x06kBreak\x10\x00\x12\f\n" +
	"\bkThrough\x10\x01\x12\b\n" +
	"\x04kVia\x10\x02\x12\x11\n" +
	"\rkBreakThrough\x10\x03\"3\n" +
	"\rPreferredSide\x12\n" +
	"\n" +
	"\x06either\x10\x00\x12\b\n" +
	"\x04same\x10\x01\x12\f\n" +
	"\bopposite\x10\x02\"0\n" +
	"\fSideOfStreet\x12\t\n" +
	"\x05kNone\x10\x00\x12\t\n" +
	"\x05kLeft\x10\x01\x12\n" +
	"\n" +
	"\x06kRight\x10\x02B\r\n" +
	"\vhas_headingB\x17\n" +
	"\x15has_heading_toleranceB\x19\n" +
	"\x17has_node_snap_toleranceB\x1a\n" +
	"\x18has_minimum_reachabilityB\f\n" +
	"\n" +
	"has_radiusB\x0e\n" +
	"\fhas_accuracyB\n" +
	"\n" +
	"\bhas_timeB\x13\n" +
	"\x11has_search_cutoffB\x1b\n" +
	"\x19has_street_side_toleranceB\x1e\n" +
	"\x1chas_street_side_max_distanceB\x15\n" +
	"\x13has_preferred_layerB\x18\n" +
	"\x16has_street_side_cutoff\"h\n" +
	"\x11TransitEgressInfo\x12\x1d\n" +
	"\n" +
	"onestop_id\x18\x01 \x01(\tR\tonestopId\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12 \n" +
	"\x02ll\x18\x03 \x01(\v2\x10.valhalla.LatLngR\x02ll\"i\n" +
	"\x12TransitStationInfo\x12\x1d\n" +
	"\n" +
	"onestop_id\x18\x01 \x01(\tR\tonestopId\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12 \n" +
	"\x02ll\x18\x03 \x01(\v2\x10.valhalla.LatLngR\x02ll\"\xcc\x01\n" +
	"\x14BikeShareStationInfo\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x10\n" +
	"\x03ref\x18\x02 \x01(\tR\x03ref\x12\x1a\n" +
	"\bcapacity\x18\x03 \x01(\rR\bcapacity\x12\x18\n" +
	"\anetwork\x18\x04 \x01(\tR\anetwork\x12\x1a\n" +
	"\boperator\x18\x05 \x01(\tR\boperator\x12\x1b\n" +
	"\trent_cost\x18\x06 \x01(\x02R\brentCost\x12\x1f\n" +
	"\vreturn_cost\x18\a \x01(\x02R\n" +
	"returnCost\"\x9b\x03\n" +
	"\x13TransitPlatformInfo\x126\n" +
	"\x04type\x18\x01 \x01(\x0e2\".valhalla.TransitPlatformInfo.TypeR\x04type\x12\x1d\n" +
	"\n" +
	"onestop_id\x18\x02 \x01(\tR\tonestopId\x12\x12\n" +
	"\x04name\x18\x03 \x01(\tR\x04name\x12*\n" +
	"\x11arrival_date_time\x18\x04 \x01(\tR\x0farrivalDateTime\x12.\n" +
	"\x13departure_date_time\x18\x05 \x01(\tR\x11departureDateTime\x12)\n" +
	"\x10assumed_schedule\x18\x06 \x01(\bR\x0fassumedSchedule\x12 \n" +
	"\x02ll\x18\a \x01(\v2\x10.valhalla.LatLngR\x02ll\x12,\n" +
	"\x12station_onestop_id\x18\b \x01(\tR\x10stationOnestopId\x12!\n" +
	"\fstation_name\x18\t \x01(\tR\vstationName\"\x1f\n" +
	"\x04Type\x12\t\n" +
	"\x05kStop\x10\x00\x12\f\n" +
	"\bkStation\x10\x01\"\xd0\x03\n" +
	"\x10TransitRouteInfo\x12\x1d\n" +
	"\n" +
	"onestop_id\x18\x01 \x01(\tR\tonestopId\x12\x19\n" +
	"\bblock_id\x18\x02 \x01(\rR\ablockId\x12\x17\n" +
	"\atrip_id\x18\x03 \x01(\rR\x06tripId\x12\x1d\n" +
	"\n" +
	"short_name\x18\x04 \x01(\tR\tshortName\x12\x1b\n" +
	"\tlong_name\x18\x05 \x01(\tR\blongName\x12\x1a\n" +
	"\bheadsign\x18\x06 \x01(\tR\bheadsign\x12\x14\n" +
	"\x05color\x18\a \x01(\rR\x05color\x12\x1d\n" +
	"\n" +
	"text_color\x18\b \x01(\rR\ttextColor\x12 \n" +
	"\vdescription\x18\t \x01(\tR\vdescription\x12.\n" +
	"\x13operator_onestop_id\x18\n" +
	" \x01(\tR\x11operatorOnestopId\x12#\n" +
	"\roperator_name\x18\v \x01(\tR\foperatorName\x12!\n" +
	"\foperator_url\x18\f \x01(\tR\voperatorUrl\x12B\n" +
	"\rtransit_stops\x18\r \x03(\v2\x1d.valhalla.TransitPlatformInfoR\ftransitStops\"\xad\x01\n" +
	"\rPronunciation\x12<\n" +
	"\balphabet\x18\x01 \x01(\x0e2 .valhalla.Pronunciation.AlphabetR\balphabet\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value\"H\n" +
	"\bAlphabet\x12\t\n" +
	"\x05kNone\x10\x00\x12\b\n" +
	"\x04kIpa\x10\x01\x12\r\n" +
	"\tkKatakana\x10\x02\x12\n" +
	"\n" +
	"\x06kJeita\x10\x03\x12\f\n" +
	"\bkNtSampa\x10\x04\"\xc3\x01\n" +
	"\n" +
	"StreetName\x12\x14\n" +
	"\x05value\x18\x01 \x01(\tR\x05value\x12&\n" +
	"\x0fis_route_number\x18\x02 \x01(\bR\risRouteNumber\x12=\n" +
	"\rpronunciation\x18\x03 \x01(\v2\x17.valhalla.PronunciationR\rpronunciation\x128\n" +
	"\flanguage_tag\x18\x04 \x01(\x0e2\x15.valhalla.LanguageTagR\vlanguageTag\"\xbe\x01\n" +
	"\bTurnLane\x12'\n" +
	"\x0fdirections_mask\x18\x01 \x01(\rR\x0edirectionsMask\x12.\n" +
	"\x05state\x18\x02 \x01(\x0e2\x18.valhalla.TurnLane.StateR\x05state\x12)\n" +
	"\x10active_direction\x18\x03 \x01(\rR\x0factiveDirection\".\n" +
	"\x05State\x12\f\n" +
	"\bkInvalid\x10\x00\x12\n" +
	"\n" +
	"\x06kValid\x10\x01\x12\v\n" +
	"\akActive\x10\x02\"\x83\x02\n" +
	"\vTaggedValue\x12\x14\n" +
	"\x05value\x18\x01 \x01(\fR\x05value\x12.\n" +
	"\x04type\x18\x02 \x01(\x0e2\x1a.valhalla.TaggedValue.TypeR\x04type\"\xad\x01\n" +
	"\x04Type\x12\t\n" +
	"\x05kNone\x10\x00\x12\n" +
	"\n" +
	"\x06kLayer\x10\x01\x12\x12\n" +
	"\x0ekPronunciation\x10\x02\x12\f\n" +
	"\bkBssInfo\x10\x03\x12\n" +
	"\n" +
	"\x06kLevel\x10\x04\x12\r\n" +
	"\tkLevelRef\x10\x05\x12\r\n" +
	"\tkLandmark\x10\x06\x12\x1b\n" +
	"\x17kConditionalSpeedLimits\x10\a\x12\v\n" +
	"\akLevels\x10\b\x12\v\n" +
	"\akTunnel\x101\x12\v\n" +
	"\akBridge\x102\"\xed\x01\n" +
	"\aSummary\x12\x16\n" +
	"\x06length\x18\x01 \x01(\x02R\x06length\x12\x12\n" +
	"\x04time\x18\x02 \x01(\x01R\x04time\x12)\n" +
	"\x04bbox\x18\x03 \x01(\v2\x15.valhalla.BoundingBoxR\x04bbox\x122\n" +
	"\x15has_time_restrictions\x18\x04 \x01(\bR\x13hasTimeRestrictions\x12\x19\n" +
	"\bhas_toll\x18\x05 \x01(\bR\ahasToll\x12\x1b\n" +
	"\thas_ferry\x18\x06 \x01(\bR\bhasFerry\x12\x1f\n" +
	"\vhas_highway\x18\a \x01(\bR\n" +
	"hasHighway\"b\n" +
	"\vLevelChange\x12\x1f\n" +
	"\vshape_index\x18\x01 \x01(\rR\n" +
	"shapeIndex\x12\x14\n" +
	"\x05level\x18\x02 \x01(\x02R\x05level\x12\x1c\n" +
	"\tprecision\x18\x03 \x01(\rR\tprecision*\xad\x05\n" +
	"\vLanguageTag\x12\x10\n" +
	"\fkUnspecified\x10\x00\x12\a\n" +
	"\x03kAb\x10\x01\x12\a\n" +
	"\x03kAm\x10\x02\x12\a\n" +
	"\x03kAr\x10\x03\x12\a\n" +
	"\x03kAz\x10\x04\x12\a\n" +
	"\x03kBe\x10\x05\x12\a\n" +
	"\x03kBg\x10\x06\x12\a\n" +
	"\x03kBn\x10\a\x12\a\n" +
	"\x03kBs\x10\b\x12\a\n" +
	"\x03kCa\x10\t\x12\b\n" +
	"\x04kCkb\x10\n" +
	"\x12\a\n" +
	"\x03kCs\x10\v\x12\a\n" +
	"\x03kDa\x10\f\x12\a\n" +
	"\x03kDe\x10\r\x12\a\n" +
	"\x03kDv\x10\x0e\x12\a\n" +
	"\x03kDz\x10\x0f\x12\a\n" +
	"\x03kEl\x10\x10\x12\a\n" +
	"\x03kEn\x10\x11\x12\a\n" +
	"\x03kEs\x10\x12\x12\a\n" +
	"\x03kEt\x10\x13\x12\a\n" +
	"\x03kFa\x10\x14\x12\a\n" +
	"\x03kFi\x10\x15\x12\a\n" +
	"\x03kFr\x10\x16\x12\a\n" +
	"\x03kFy\x10\x17\x12\a\n" +
	"\x03kGl\x10\x18\x12\a\n" +
	"\x03kHe\x10\x19\x12\a\n" +
	"\x03kHr\x10\x1a\x12\a\n" +
	"\x03kHu\x10\x1b\x12\a\n" +
	"\x03kHy\x10\x1c\x12\a\n" +
	"\x03kId\x10\x1d\x12\a\n" +
	"\x03kIs\x10\x1e\x12\a\n" +
	"\x03kIt\x10\x1f\x12\a\n" +
	"\x03kJa\x10 \x12\a\n" +
	"\x03kKa\x10!\x12\a\n" +
	"\x03kKl\x10\"\x12\a\n" +
	"\x03kKm\x10#\x12\a\n" +
	"\x03kKo\x10$\x12\a\n" +
	"\x03kLo\x10%\x12\a\n" +
	"\x03kLt\x10&\x12\a\n" +
	"\x03kLv\x10'\x12\a\n" +
	"\x03kMg\x10(\x12\a\n" +
	"\x03kMk\x10)\x12\a\n" +
	"\x03kMn\x10*\x12\a\n" +
	"\x03kMo\x10+\x12\a\n" +
	"\x03kMt\x10,\x12\a\n" +
	"\x03kMy\x10-\x12\a\n" +
	"\x03kNe\x10.\x12\a\n" +
	"\x03kNl\x10/\x12\a\n" +
	"\x03kNo\x100\x12\a\n" +
	"\x03kOc\x101\x12\b\n" +
	"\x04kPap\x102\x12\a\n" +
	"\x03kPl\x103\x12\a\n" +
	"\x03kPs\x104\x12\a\n" +
	"\x03kPt\x105\x12\a\n" +
	"\x03kRm\x106\x12\a\n" +
	"\x03kRo\x107\x12\a\n" +
	"\x03kRu\x108\x12\a\n" +
	"\x03kSk\x109\x12\a\n" +
	"\x03kSl\x10:\x12\a\n" +
	"\x03kSq\x10;\x12\a\n" +
	"\x03kSr\x10<\x12\v\n" +
	"\akSrLatn\x10=\x12\a\n" +
	"\x03kSv\x10>\x12\a\n" +
	"\x03kTg\x10?\x12\a\n" +
	"\x03kTh\x10@\x12\a\n" +
	"\x03kTk\x10A\x12\a\n" +
	"\x03kTr\x10B\x12\a\n" +
	"\x03kUk\x10C\x12\a\n" +
	"\x03kUr\x10D\x12\a\n" +
	"\x03kUz\x10E\x12\a\n" +
	"\x03kVi\x10F\x12\a\n" +
	"\x03kZh\x10G\x12\a\n" +
	"\x03kCy\x10H*\x8b\x01\n" +
	"\tRoadClass\x12\r\n" +
	"\tkMotorway\x10\x00\x12\n" +
	"\n" +
	"\x06kTrunk\x10\x01\x12\f\n" +
	"\bkPrimary\x10\x02\x12\x0e\n" +
	"\n" +
	"kSecondary\x10\x03\x12\r\n" +
	"\tkTertiary\x10\x04\x12\x11\n" +
	"\rkUnclassified\x10\x05\x12\x10\n" +
	"\fkResidential\x10\x06\x12\x11\n" +
	"\rkServiceOther\x10\a*E\n" +
	"\n" +
	"TravelMode\x12\n" +
	"\n" +
	"\x06kDrive\x10\x00\x12\x0f\n" +
	"\vkPedestrian\x10\x01\x12\f\n" +
	"\bkBicycle\x10\x02\x12\f\n" +
	"\bkTransit\x10\x03*U\n" +
	"\vVehicleType\x12\b\n" +
	"\x04kCar\x10\x00\x12\x0f\n" +
	"\vkMotorcycle\x10\x01\x12\f\n" +
	"\bkAutoBus\x10\x02\x12\n" +
	"\n" +
	"\x06kTruck\x10\x03\x12\x11\n" +
	"\rkMotorScooter\x10\x04*8\n" +
	"\x0ePedestrianType\x12\t\n" +
	"\x05kFoot\x10\x00\x12\x0f\n" +
	"\vkWheelchair\x10\x01\x12\n" +
	"\n" +
	"\x06kBlind\x10\x02*@\n" +
	"\vBicycleType\x12\t\n" +
	"\x05kRoad\x10\x00\x12\n" +
	"\n" +
	"\x06kCross\x10\x01\x12\v\n" +
	"\akHybrid\x10\x02\x12\r\n" +
	"\tkMountain\x10\x03*r\n" +
	"\vTransitType\x12\t\n" +
	"\x05kTram\x10\x00\x12\n" +
	"\n" +
	"\x06kMetro\x10\x01\x12\t\n" +
	"\x05kRail\x10\x02\x12\b\n" +
	"\x04kBus\x10\x03\x12\n" +
	"\n" +
	"\x06kFerry\x10\x04\x12\r\n" +
	"\tkCableCar\x10\x05\x12\f\n" +
	"\bkGondola\x10\x06\x12\x0e\n" +
	"\n" +
	"kFunicular\x10\aBIH\x03ZEmatching-engine/internal/adapter/routing-engine/valhalla/client/pb;pbb\x06proto3"

var (
	file_common_proto_rawDescOnce sync.Once
	file_common_proto_rawDescData []byte
)

func file_common_proto_rawDescGZIP() []byte {
	file_common_proto_rawDescOnce.Do(func() {
		file_common_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_common_proto_rawDesc), len(file_common_proto_rawDesc)))
	})
	return file_common_proto_rawDescData
}

var file_common_proto_enumTypes = make([]protoimpl.EnumInfo, 15)
var file_common_proto_msgTypes = make([]protoimpl.MessageInfo, 18)
var file_common_proto_goTypes = []any{
	(LanguageTag)(0),              // 0: valhalla.LanguageTag
	(RoadClass)(0),                // 1: valhalla.RoadClass
	(TravelMode)(0),               // 2: valhalla.TravelMode
	(VehicleType)(0),              // 3: valhalla.VehicleType
	(PedestrianType)(0),           // 4: valhalla.PedestrianType
	(BicycleType)(0),              // 5: valhalla.BicycleType
	(TransitType)(0),              // 6: valhalla.TransitType
	(RouteLandmark_Type)(0),       // 7: valhalla.RouteLandmark.Type
	(Location_Type)(0),            // 8: valhalla.Location.Type
	(Location_PreferredSide)(0),   // 9: valhalla.Location.PreferredSide
	(Location_SideOfStreet)(0),    // 10: valhalla.Location.SideOfStreet
	(TransitPlatformInfo_Type)(0), // 11: valhalla.TransitPlatformInfo.Type
	(Pronunciation_Alphabet)(0),   // 12: valhalla.Pronunciation.Alphabet
	(TurnLane_State)(0),           // 13: valhalla.TurnLane.State
	(TaggedValue_Type)(0),         // 14: valhalla.TaggedValue.Type
	(*LatLng)(nil),                // 15: valhalla.LatLng
	(*RouteLandmark)(nil),         // 16: valhalla.RouteLandmark
	(*BoundingBox)(nil),           // 17: valhalla.BoundingBox
	(*SearchFilter)(nil),          // 18: valhalla.SearchFilter
	(*PathEdge)(nil),              // 19: valhalla.PathEdge
	(*Correlation)(nil),           // 20: valhalla.Correlation
	(*Location)(nil),              // 21: valhalla.Location
	(*TransitEgressInfo)(nil),     // 22: valhalla.TransitEgressInfo
	(*TransitStationInfo)(nil),    // 23: valhalla.TransitStationInfo
	(*BikeShareStationInfo)(nil),  // 24: valhalla.BikeShareStationInfo
	(*TransitPlatformInfo)(nil),   // 25: valhalla.TransitPlatformInfo
	(*TransitRouteInfo)(nil),      // 26: valhalla.TransitRouteInfo
	(*Pronunciation)(nil),         // 27: valhalla.Pronunciation
	(*StreetName)(nil),            // 28: valhalla.StreetName
	(*TurnLane)(nil),              // 29: valhalla.TurnLane
	(*TaggedValue)(nil),           // 30: valhalla.TaggedValue
	(*Summary)(nil),               // 31: valhalla.Summary
	(*LevelChange)(nil),           // 32: valhalla.LevelChange
}
var file_common_proto_depIdxs = []int32{
	7,  // 0: valhalla.RouteLandmark.type:type_name -> valhalla.RouteLandmark.Type
	15, // 1: valhalla.RouteLandmark.lat_lng:type_name -> valhalla.LatLng
	15, // 2: valhalla.BoundingBox.min_ll:type_name -> valhalla.LatLng
	15, // 3: valhalla.BoundingBox.max_ll:type_name -> valhalla.LatLng
	1,  // 4: valhalla.SearchFilter.min_road_class:type_name -> valhalla.RoadClass
	1,  // 5: valhalla.SearchFilter.max_road_class:type_name -> valhalla.RoadClass
	15, // 6: valhalla.PathEdge.ll:type_name -> valhalla.LatLng
	10, // 7: valhalla.PathEdge.side_of_street:type_name -> valhalla.Location.SideOfStreet
	19, // 8: valhalla.Correlation.edges:type_name -> valhalla.PathEdge
	19, // 9: valhalla.Correlation.filtered_edges:type_name -> valhalla.PathEdge
	15, // 10: valhalla.Correlation.projected_ll:type_name -> valhalla.LatLng
	15, // 11: valhalla.Location.ll:type_name -> valhalla.LatLng
	8,  // 12: valhalla.Location.type:type_name -> valhalla.Location.Type
	10, // 13: valhalla.Location.side_of_street:type_name -> valhalla.Location.SideOfStreet
	9,  // 14: valhalla.Location.preferred_side:type_name -> valhalla.Location.PreferredSide
	15, // 15: valhalla.Location.display_ll:type_name -> valhalla.LatLng
	18, // 16: valhalla.Location.search_filter:type_name -> valhalla.SearchFilter
	1,  // 17: valhalla.Location.street_side_cutoff:type_name -> valhalla.RoadClass
	20, // 18: valhalla.Location.correlation:type_name -> valhalla.Correlation
	15, // 19: valhalla.TransitEgressInfo.ll:type_name -> valhalla.LatLng
	15, // 20: valhalla.TransitStationInfo.ll:type_name -> valhalla.LatLng
	11, // 21: valhalla.TransitPlatformInfo.type:type_name -> valhalla.TransitPlatformInfo.Type
	15, // 22: valhalla.TransitPlatformInfo.ll:type_name -> valhalla.LatLng
	25, // 23: valhalla.TransitRouteInfo.transit_stops:type_name -> valhalla.TransitPlatformInfo
	12, // 24: valhalla.Pronunciation.alphabet:type_name -> valhalla.Pronunciation.Alphabet
	27, // 25: valhalla.StreetName.pronunciation:type_name -> valhalla.Pronunciation
	0,  // 26: valhalla.StreetName.language_tag:type_name -> valhalla.LanguageTag
	13, // 27: valhalla.TurnLane.state:type_name -> valhalla.TurnLane.State
	14, // 28: valhalla.TaggedValue.type:type_name -> valhalla.TaggedValue.Type
	17, // 29: valhalla.Summary.bbox:type_name -> valhalla.BoundingBox
	30, // [30:30] is the sub-list for method output_type
	30, // [30:30] is the sub-list for method input_type
	30, // [30:30] is the sub-list for extension type_name
	30, // [30:30] is the sub-list for extension extendee
	0,  // [0:30] is the sub-list for field type_name
}

func init() { file_common_proto_init() }
func file_common_proto_init() {
	if File_common_proto != nil {
		return
	}
	file_common_proto_msgTypes[0].OneofWrappers = []any{
		(*LatLng_Lat)(nil),
		(*LatLng_Lng)(nil),
	}
	file_common_proto_msgTypes[3].OneofWrappers = []any{
		(*SearchFilter_MinRoadClass)(nil),
		(*SearchFilter_MaxRoadClass)(nil),
		(*SearchFilter_ExcludeClosures)(nil),
		(*SearchFilter_Level)(nil),
	}
	file_common_proto_msgTypes[6].OneofWrappers = []any{
		(*Location_Heading)(nil),
		(*Location_HeadingTolerance)(nil),
		(*Location_NodeSnapTolerance)(nil),
		(*Location_MinimumReachability)(nil),
		(*Location_Radius)(nil),
		(*Location_Accuracy)(nil),
		(*Location_Time)(nil),
		(*Location_SearchCutoff)(nil),
		(*Location_StreetSideTolerance)(nil),
		(*Location_StreetSideMaxDistance)(nil),
		(*Location_PreferredLayer)(nil),
		(*Location_StreetSideCutoff)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_common_proto_rawDesc), len(file_common_proto_rawDesc)),
			NumEnums:      15,
			NumMessages:   18,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_common_proto_goTypes,
		DependencyIndexes: file_common_proto_depIdxs,
		EnumInfos:         file_common_proto_enumTypes,
		MessageInfos:      file_common_proto_msgTypes,
	}.Build()
	File_common_proto = out.File
	file_common_proto_goTypes = nil
	file_common_proto_depIdxs = nil
}
