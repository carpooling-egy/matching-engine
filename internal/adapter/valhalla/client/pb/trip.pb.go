// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v6.30.2
// source: trip.proto

package pb

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type TripLeg_Traversability int32

const (
	TripLeg_kNone     TripLeg_Traversability = 0
	TripLeg_kForward  TripLeg_Traversability = 1
	TripLeg_kBackward TripLeg_Traversability = 2
	TripLeg_kBoth     TripLeg_Traversability = 3
)

// Enum value maps for TripLeg_Traversability.
var (
	TripLeg_Traversability_name = map[int32]string{
		0: "kNone",
		1: "kForward",
		2: "kBackward",
		3: "kBoth",
	}
	TripLeg_Traversability_value = map[string]int32{
		"kNone":     0,
		"kForward":  1,
		"kBackward": 2,
		"kBoth":     3,
	}
)

func (x TripLeg_Traversability) Enum() *TripLeg_Traversability {
	p := new(TripLeg_Traversability)
	*p = x
	return p
}

func (x TripLeg_Traversability) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TripLeg_Traversability) Descriptor() protoreflect.EnumDescriptor {
	return file_trip_proto_enumTypes[0].Descriptor()
}

func (TripLeg_Traversability) Type() protoreflect.EnumType {
	return &file_trip_proto_enumTypes[0]
}

func (x TripLeg_Traversability) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TripLeg_Traversability.Descriptor instead.
func (TripLeg_Traversability) EnumDescriptor() ([]byte, []int) {
	return file_trip_proto_rawDescGZIP(), []int{0, 0}
}

type TripLeg_Use int32

const (
	TripLeg_kRoadUse            TripLeg_Use = 0
	TripLeg_kRampUse            TripLeg_Use = 1 // Link - exits/entrance ramps.
	TripLeg_kTurnChannelUse     TripLeg_Use = 2 // Link - turn lane.
	TripLeg_kTrackUse           TripLeg_Use = 3 // Agricultural use; forest tracks
	TripLeg_kDrivewayUse        TripLeg_Use = 4 // Driveway/private service
	TripLeg_kAlleyUse           TripLeg_Use = 5 // Service road - limited route use
	TripLeg_kParkingAisleUse    TripLeg_Use = 6 // Access roads in parking areas
	TripLeg_kEmergencyAccessUse TripLeg_Use = 7 // Emergency vehicles only
	TripLeg_kDriveThruUse       TripLeg_Use = 8 // Commercial drive-thru (banks/fast-food)
	TripLeg_kCuldesacUse        TripLeg_Use = 9 // Cul-de-sac (edge that forms a loop and is only
	// connected at one node to another edge.
	TripLeg_kLivingStreetUse TripLeg_Use = 10 // Shared space for cars, bikes, pedestrians
	TripLeg_kServiceRoadUse  TripLeg_Use = 11 // Generic service road (not driveway, alley, parking aisle, etc.)
	// Bicycle specific uses
	TripLeg_kCyclewayUse     TripLeg_Use = 20 // Dedicated bicycle path
	TripLeg_kMountainBikeUse TripLeg_Use = 21 // Mountain bike trail
	TripLeg_kSidewalkUse     TripLeg_Use = 24
	// Pedestrian specific uses
	TripLeg_kFootwayUse            TripLeg_Use = 25
	TripLeg_kStepsUse              TripLeg_Use = 26 // Stairs
	TripLeg_kPathUse               TripLeg_Use = 27
	TripLeg_kPedestrianUse         TripLeg_Use = 28
	TripLeg_kBridlewayUse          TripLeg_Use = 29
	TripLeg_kPedestrianCrossingUse TripLeg_Use = 32
	TripLeg_kElevatorUse           TripLeg_Use = 33
	TripLeg_kEscalatorUse          TripLeg_Use = 34
	// Rest/Service Areas
	TripLeg_kRestAreaUse    TripLeg_Use = 30
	TripLeg_kServiceAreaUse TripLeg_Use = 31
	// Other...
	TripLeg_kOtherUse TripLeg_Use = 40
	// Ferry and rail ferry
	TripLeg_kFerryUse        TripLeg_Use = 41
	TripLeg_kRailFerryUse    TripLeg_Use = 42
	TripLeg_kConstructionUse TripLeg_Use = 43 // Road under construction
	// Transit specific uses. Must be last in the list
	TripLeg_kRailUse               TripLeg_Use = 50 // Rail line
	TripLeg_kBusUse                TripLeg_Use = 51 // Bus line
	TripLeg_kEgressConnectionUse   TripLeg_Use = 52 // Connection between transit station and transit egress
	TripLeg_kPlatformConnectionUse TripLeg_Use = 53 // Connection between transit station and transit platform
	TripLeg_kTransitConnectionUse  TripLeg_Use = 54 // Connection between road network and transit egress
)

// Enum value maps for TripLeg_Use.
var (
	TripLeg_Use_name = map[int32]string{
		0:  "kRoadUse",
		1:  "kRampUse",
		2:  "kTurnChannelUse",
		3:  "kTrackUse",
		4:  "kDrivewayUse",
		5:  "kAlleyUse",
		6:  "kParkingAisleUse",
		7:  "kEmergencyAccessUse",
		8:  "kDriveThruUse",
		9:  "kCuldesacUse",
		10: "kLivingStreetUse",
		11: "kServiceRoadUse",
		20: "kCyclewayUse",
		21: "kMountainBikeUse",
		24: "kSidewalkUse",
		25: "kFootwayUse",
		26: "kStepsUse",
		27: "kPathUse",
		28: "kPedestrianUse",
		29: "kBridlewayUse",
		32: "kPedestrianCrossingUse",
		33: "kElevatorUse",
		34: "kEscalatorUse",
		30: "kRestAreaUse",
		31: "kServiceAreaUse",
		40: "kOtherUse",
		41: "kFerryUse",
		42: "kRailFerryUse",
		43: "kConstructionUse",
		50: "kRailUse",
		51: "kBusUse",
		52: "kEgressConnectionUse",
		53: "kPlatformConnectionUse",
		54: "kTransitConnectionUse",
	}
	TripLeg_Use_value = map[string]int32{
		"kRoadUse":               0,
		"kRampUse":               1,
		"kTurnChannelUse":        2,
		"kTrackUse":              3,
		"kDrivewayUse":           4,
		"kAlleyUse":              5,
		"kParkingAisleUse":       6,
		"kEmergencyAccessUse":    7,
		"kDriveThruUse":          8,
		"kCuldesacUse":           9,
		"kLivingStreetUse":       10,
		"kServiceRoadUse":        11,
		"kCyclewayUse":           20,
		"kMountainBikeUse":       21,
		"kSidewalkUse":           24,
		"kFootwayUse":            25,
		"kStepsUse":              26,
		"kPathUse":               27,
		"kPedestrianUse":         28,
		"kBridlewayUse":          29,
		"kPedestrianCrossingUse": 32,
		"kElevatorUse":           33,
		"kEscalatorUse":          34,
		"kRestAreaUse":           30,
		"kServiceAreaUse":        31,
		"kOtherUse":              40,
		"kFerryUse":              41,
		"kRailFerryUse":          42,
		"kConstructionUse":       43,
		"kRailUse":               50,
		"kBusUse":                51,
		"kEgressConnectionUse":   52,
		"kPlatformConnectionUse": 53,
		"kTransitConnectionUse":  54,
	}
)

func (x TripLeg_Use) Enum() *TripLeg_Use {
	p := new(TripLeg_Use)
	*p = x
	return p
}

func (x TripLeg_Use) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TripLeg_Use) Descriptor() protoreflect.EnumDescriptor {
	return file_trip_proto_enumTypes[1].Descriptor()
}

func (TripLeg_Use) Type() protoreflect.EnumType {
	return &file_trip_proto_enumTypes[1]
}

func (x TripLeg_Use) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TripLeg_Use.Descriptor instead.
func (TripLeg_Use) EnumDescriptor() ([]byte, []int) {
	return file_trip_proto_rawDescGZIP(), []int{0, 1}
}

type TripLeg_Surface int32

const (
	TripLeg_kPavedSmooth TripLeg_Surface = 0
	TripLeg_kPaved       TripLeg_Surface = 1
	TripLeg_kPavedRough  TripLeg_Surface = 2
	TripLeg_kCompacted   TripLeg_Surface = 3
	TripLeg_kDirt        TripLeg_Surface = 4
	TripLeg_kGravel      TripLeg_Surface = 5
	TripLeg_kPath        TripLeg_Surface = 6
	TripLeg_kImpassable  TripLeg_Surface = 7
)

// Enum value maps for TripLeg_Surface.
var (
	TripLeg_Surface_name = map[int32]string{
		0: "kPavedSmooth",
		1: "kPaved",
		2: "kPavedRough",
		3: "kCompacted",
		4: "kDirt",
		5: "kGravel",
		6: "kPath",
		7: "kImpassable",
	}
	TripLeg_Surface_value = map[string]int32{
		"kPavedSmooth": 0,
		"kPaved":       1,
		"kPavedRough":  2,
		"kCompacted":   3,
		"kDirt":        4,
		"kGravel":      5,
		"kPath":        6,
		"kImpassable":  7,
	}
)

func (x TripLeg_Surface) Enum() *TripLeg_Surface {
	p := new(TripLeg_Surface)
	*p = x
	return p
}

func (x TripLeg_Surface) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TripLeg_Surface) Descriptor() protoreflect.EnumDescriptor {
	return file_trip_proto_enumTypes[2].Descriptor()
}

func (TripLeg_Surface) Type() protoreflect.EnumType {
	return &file_trip_proto_enumTypes[2]
}

func (x TripLeg_Surface) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TripLeg_Surface.Descriptor instead.
func (TripLeg_Surface) EnumDescriptor() ([]byte, []int) {
	return file_trip_proto_rawDescGZIP(), []int{0, 2}
}

type TripLeg_CycleLane int32

const (
	TripLeg_kNoCycleLane TripLeg_CycleLane = 0
	TripLeg_kShared      TripLeg_CycleLane = 1 // Shared use lane (could be shared with pedestrians)
	TripLeg_kDedicated   TripLeg_CycleLane = 2 // Dedicated cycle lane
	TripLeg_kSeparated   TripLeg_CycleLane = 3 // A separate cycle lane (physical separation from the main carriageway
)

// Enum value maps for TripLeg_CycleLane.
var (
	TripLeg_CycleLane_name = map[int32]string{
		0: "kNoCycleLane",
		1: "kShared",
		2: "kDedicated",
		3: "kSeparated",
	}
	TripLeg_CycleLane_value = map[string]int32{
		"kNoCycleLane": 0,
		"kShared":      1,
		"kDedicated":   2,
		"kSeparated":   3,
	}
)

func (x TripLeg_CycleLane) Enum() *TripLeg_CycleLane {
	p := new(TripLeg_CycleLane)
	*p = x
	return p
}

func (x TripLeg_CycleLane) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TripLeg_CycleLane) Descriptor() protoreflect.EnumDescriptor {
	return file_trip_proto_enumTypes[3].Descriptor()
}

func (TripLeg_CycleLane) Type() protoreflect.EnumType {
	return &file_trip_proto_enumTypes[3]
}

func (x TripLeg_CycleLane) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TripLeg_CycleLane.Descriptor instead.
func (TripLeg_CycleLane) EnumDescriptor() ([]byte, []int) {
	return file_trip_proto_rawDescGZIP(), []int{0, 3}
}

type TripLeg_SacScale int32

const (
	TripLeg_kNoSacScale              TripLeg_SacScale = 0
	TripLeg_kHiking                  TripLeg_SacScale = 1
	TripLeg_kMountainHiking          TripLeg_SacScale = 2
	TripLeg_kDemandingMountainHiking TripLeg_SacScale = 3
	TripLeg_kAlpineHiking            TripLeg_SacScale = 4
	TripLeg_kDemandingAlpineHiking   TripLeg_SacScale = 5
	TripLeg_kDifficultAlpineHiking   TripLeg_SacScale = 6
)

// Enum value maps for TripLeg_SacScale.
var (
	TripLeg_SacScale_name = map[int32]string{
		0: "kNoSacScale",
		1: "kHiking",
		2: "kMountainHiking",
		3: "kDemandingMountainHiking",
		4: "kAlpineHiking",
		5: "kDemandingAlpineHiking",
		6: "kDifficultAlpineHiking",
	}
	TripLeg_SacScale_value = map[string]int32{
		"kNoSacScale":              0,
		"kHiking":                  1,
		"kMountainHiking":          2,
		"kDemandingMountainHiking": 3,
		"kAlpineHiking":            4,
		"kDemandingAlpineHiking":   5,
		"kDifficultAlpineHiking":   6,
	}
)

func (x TripLeg_SacScale) Enum() *TripLeg_SacScale {
	p := new(TripLeg_SacScale)
	*p = x
	return p
}

func (x TripLeg_SacScale) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TripLeg_SacScale) Descriptor() protoreflect.EnumDescriptor {
	return file_trip_proto_enumTypes[4].Descriptor()
}

func (TripLeg_SacScale) Type() protoreflect.EnumType {
	return &file_trip_proto_enumTypes[4]
}

func (x TripLeg_SacScale) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TripLeg_SacScale.Descriptor instead.
func (TripLeg_SacScale) EnumDescriptor() ([]byte, []int) {
	return file_trip_proto_rawDescGZIP(), []int{0, 4}
}

type TripLeg_Sidewalk int32

const (
	TripLeg_kNoSidewalk TripLeg_Sidewalk = 0
	TripLeg_kLeft       TripLeg_Sidewalk = 1
	TripLeg_kRight      TripLeg_Sidewalk = 2
	TripLeg_kBothSides  TripLeg_Sidewalk = 3
)

// Enum value maps for TripLeg_Sidewalk.
var (
	TripLeg_Sidewalk_name = map[int32]string{
		0: "kNoSidewalk",
		1: "kLeft",
		2: "kRight",
		3: "kBothSides",
	}
	TripLeg_Sidewalk_value = map[string]int32{
		"kNoSidewalk": 0,
		"kLeft":       1,
		"kRight":      2,
		"kBothSides":  3,
	}
)

func (x TripLeg_Sidewalk) Enum() *TripLeg_Sidewalk {
	p := new(TripLeg_Sidewalk)
	*p = x
	return p
}

func (x TripLeg_Sidewalk) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TripLeg_Sidewalk) Descriptor() protoreflect.EnumDescriptor {
	return file_trip_proto_enumTypes[5].Descriptor()
}

func (TripLeg_Sidewalk) Type() protoreflect.EnumType {
	return &file_trip_proto_enumTypes[5]
}

func (x TripLeg_Sidewalk) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TripLeg_Sidewalk.Descriptor instead.
func (TripLeg_Sidewalk) EnumDescriptor() ([]byte, []int) {
	return file_trip_proto_rawDescGZIP(), []int{0, 5}
}

type TripLeg_TimeDomain_DayDowType int32

const (
	TripLeg_TimeDomain_kDayOfMonth   TripLeg_TimeDomain_DayDowType = 0 // day_dow is a day of month in range [1,31]
	TripLeg_TimeDomain_kNthDayOfWeek TripLeg_TimeDomain_DayDowType = 1 // day_dow is a day of week in range [1,7]
)

// Enum value maps for TripLeg_TimeDomain_DayDowType.
var (
	TripLeg_TimeDomain_DayDowType_name = map[int32]string{
		0: "kDayOfMonth",
		1: "kNthDayOfWeek",
	}
	TripLeg_TimeDomain_DayDowType_value = map[string]int32{
		"kDayOfMonth":   0,
		"kNthDayOfWeek": 1,
	}
)

func (x TripLeg_TimeDomain_DayDowType) Enum() *TripLeg_TimeDomain_DayDowType {
	p := new(TripLeg_TimeDomain_DayDowType)
	*p = x
	return p
}

func (x TripLeg_TimeDomain_DayDowType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TripLeg_TimeDomain_DayDowType) Descriptor() protoreflect.EnumDescriptor {
	return file_trip_proto_enumTypes[6].Descriptor()
}

func (TripLeg_TimeDomain_DayDowType) Type() protoreflect.EnumType {
	return &file_trip_proto_enumTypes[6]
}

func (x TripLeg_TimeDomain_DayDowType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TripLeg_TimeDomain_DayDowType.Descriptor instead.
func (TripLeg_TimeDomain_DayDowType) EnumDescriptor() ([]byte, []int) {
	return file_trip_proto_rawDescGZIP(), []int{0, 3, 0}
}

type TripLeg_Node_Type int32

const (
	TripLeg_Node_kStreetIntersection TripLeg_Node_Type = 0 // Regular intersection of 2+ roads
	TripLeg_Node_kGate               TripLeg_Node_Type = 1 // Gate or rising bollard
	TripLeg_Node_kBollard            TripLeg_Node_Type = 2 // Bollard (fixed obstruction)
	TripLeg_Node_kTollBooth          TripLeg_Node_Type = 3 // Toll booth / fare collection
	// TODO - for now there is no differentiation between bus and rail stops...
	TripLeg_Node_kTransitEgress    TripLeg_Node_Type = 4  // Transit egress
	TripLeg_Node_kTransitStation   TripLeg_Node_Type = 5  // Transit station
	TripLeg_Node_kTransitPlatform  TripLeg_Node_Type = 6  // Transit platform (rail and bus)
	TripLeg_Node_kBikeShare        TripLeg_Node_Type = 7  // Bike share location
	TripLeg_Node_kParking          TripLeg_Node_Type = 8  // Parking location
	TripLeg_Node_kMotorwayJunction TripLeg_Node_Type = 9  // Highway = motorway_junction
	TripLeg_Node_kBorderControl    TripLeg_Node_Type = 10 // Border control
	TripLeg_Node_kTollGantry       TripLeg_Node_Type = 11 // Toll gantry
	TripLeg_Node_kSumpBuster       TripLeg_Node_Type = 12 // Sump Buster
	TripLeg_Node_kBuildingEntrance TripLeg_Node_Type = 13 // Building Entrance
	TripLeg_Node_kElevator         TripLeg_Node_Type = 14 // Elevator
)

// Enum value maps for TripLeg_Node_Type.
var (
	TripLeg_Node_Type_name = map[int32]string{
		0:  "kStreetIntersection",
		1:  "kGate",
		2:  "kBollard",
		3:  "kTollBooth",
		4:  "kTransitEgress",
		5:  "kTransitStation",
		6:  "kTransitPlatform",
		7:  "kBikeShare",
		8:  "kParking",
		9:  "kMotorwayJunction",
		10: "kBorderControl",
		11: "kTollGantry",
		12: "kSumpBuster",
		13: "kBuildingEntrance",
		14: "kElevator",
	}
	TripLeg_Node_Type_value = map[string]int32{
		"kStreetIntersection": 0,
		"kGate":               1,
		"kBollard":            2,
		"kTollBooth":          3,
		"kTransitEgress":      4,
		"kTransitStation":     5,
		"kTransitPlatform":    6,
		"kBikeShare":          7,
		"kParking":            8,
		"kMotorwayJunction":   9,
		"kBorderControl":      10,
		"kTollGantry":         11,
		"kSumpBuster":         12,
		"kBuildingEntrance":   13,
		"kElevator":           14,
	}
)

func (x TripLeg_Node_Type) Enum() *TripLeg_Node_Type {
	p := new(TripLeg_Node_Type)
	*p = x
	return p
}

func (x TripLeg_Node_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TripLeg_Node_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_trip_proto_enumTypes[7].Descriptor()
}

func (TripLeg_Node_Type) Type() protoreflect.EnumType {
	return &file_trip_proto_enumTypes[7]
}

func (x TripLeg_Node_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TripLeg_Node_Type.Descriptor instead.
func (TripLeg_Node_Type) EnumDescriptor() ([]byte, []int) {
	return file_trip_proto_rawDescGZIP(), []int{0, 9, 0}
}

type TripLeg struct {
	state           protoimpl.MessageState   `protogen:"open.v1"`
	OsmChangeset    uint64                   `protobuf:"varint,1,opt,name=osm_changeset,json=osmChangeset,proto3" json:"osm_changeset,omitempty"`
	TripId          uint64                   `protobuf:"varint,2,opt,name=trip_id,json=tripId,proto3" json:"trip_id,omitempty"`
	LegId           uint32                   `protobuf:"varint,3,opt,name=leg_id,json=legId,proto3" json:"leg_id,omitempty"`
	LegCount        uint32                   `protobuf:"varint,4,opt,name=leg_count,json=legCount,proto3" json:"leg_count,omitempty"`
	Location        []*Location              `protobuf:"bytes,5,rep,name=location,proto3" json:"location,omitempty"`
	Node            []*TripLeg_Node          `protobuf:"bytes,6,rep,name=node,proto3" json:"node,omitempty"`
	Admin           []*TripLeg_Admin         `protobuf:"bytes,7,rep,name=admin,proto3" json:"admin,omitempty"`
	Shape           string                   `protobuf:"bytes,8,opt,name=shape,proto3" json:"shape,omitempty"`
	Bbox            *BoundingBox             `protobuf:"bytes,9,opt,name=bbox,proto3" json:"bbox,omitempty"`
	ShapeAttributes *TripLeg_ShapeAttributes `protobuf:"bytes,10,opt,name=shape_attributes,json=shapeAttributes,proto3" json:"shape_attributes,omitempty"`
	Incidents       []*TripLeg_Incident      `protobuf:"bytes,11,rep,name=incidents,proto3" json:"incidents,omitempty"`
	Algorithms      []string                 `protobuf:"bytes,12,rep,name=algorithms,proto3" json:"algorithms,omitempty"`
	Closures        []*TripLeg_Closure       `protobuf:"bytes,13,rep,name=closures,proto3" json:"closures,omitempty"`
	Summary         *Summary                 `protobuf:"bytes,14,opt,name=summary,proto3" json:"summary,omitempty"`
	LevelChanges    []*LevelChange           `protobuf:"bytes,15,rep,name=level_changes,json=levelChanges,proto3" json:"level_changes,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *TripLeg) Reset() {
	*x = TripLeg{}
	mi := &file_trip_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TripLeg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TripLeg) ProtoMessage() {}

func (x *TripLeg) ProtoReflect() protoreflect.Message {
	mi := &file_trip_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TripLeg.ProtoReflect.Descriptor instead.
func (*TripLeg) Descriptor() ([]byte, []int) {
	return file_trip_proto_rawDescGZIP(), []int{0}
}

func (x *TripLeg) GetOsmChangeset() uint64 {
	if x != nil {
		return x.OsmChangeset
	}
	return 0
}

func (x *TripLeg) GetTripId() uint64 {
	if x != nil {
		return x.TripId
	}
	return 0
}

func (x *TripLeg) GetLegId() uint32 {
	if x != nil {
		return x.LegId
	}
	return 0
}

func (x *TripLeg) GetLegCount() uint32 {
	if x != nil {
		return x.LegCount
	}
	return 0
}

func (x *TripLeg) GetLocation() []*Location {
	if x != nil {
		return x.Location
	}
	return nil
}

func (x *TripLeg) GetNode() []*TripLeg_Node {
	if x != nil {
		return x.Node
	}
	return nil
}

func (x *TripLeg) GetAdmin() []*TripLeg_Admin {
	if x != nil {
		return x.Admin
	}
	return nil
}

func (x *TripLeg) GetShape() string {
	if x != nil {
		return x.Shape
	}
	return ""
}

func (x *TripLeg) GetBbox() *BoundingBox {
	if x != nil {
		return x.Bbox
	}
	return nil
}

func (x *TripLeg) GetShapeAttributes() *TripLeg_ShapeAttributes {
	if x != nil {
		return x.ShapeAttributes
	}
	return nil
}

func (x *TripLeg) GetIncidents() []*TripLeg_Incident {
	if x != nil {
		return x.Incidents
	}
	return nil
}

func (x *TripLeg) GetAlgorithms() []string {
	if x != nil {
		return x.Algorithms
	}
	return nil
}

func (x *TripLeg) GetClosures() []*TripLeg_Closure {
	if x != nil {
		return x.Closures
	}
	return nil
}

func (x *TripLeg) GetSummary() *Summary {
	if x != nil {
		return x.Summary
	}
	return nil
}

func (x *TripLeg) GetLevelChanges() []*LevelChange {
	if x != nil {
		return x.LevelChanges
	}
	return nil
}

type TripRoute struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Legs          []*TripLeg             `protobuf:"bytes,1,rep,name=legs,proto3" json:"legs,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TripRoute) Reset() {
	*x = TripRoute{}
	mi := &file_trip_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TripRoute) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TripRoute) ProtoMessage() {}

func (x *TripRoute) ProtoReflect() protoreflect.Message {
	mi := &file_trip_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TripRoute.ProtoReflect.Descriptor instead.
func (*TripRoute) Descriptor() ([]byte, []int) {
	return file_trip_proto_rawDescGZIP(), []int{1}
}

func (x *TripRoute) GetLegs() []*TripLeg {
	if x != nil {
		return x.Legs
	}
	return nil
}

type Trip struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Routes        []*TripRoute           `protobuf:"bytes,1,rep,name=routes,proto3" json:"routes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Trip) Reset() {
	*x = Trip{}
	mi := &file_trip_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Trip) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Trip) ProtoMessage() {}

func (x *Trip) ProtoReflect() protoreflect.Message {
	mi := &file_trip_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Trip.ProtoReflect.Descriptor instead.
func (*Trip) Descriptor() ([]byte, []int) {
	return file_trip_proto_rawDescGZIP(), []int{2}
}

func (x *Trip) GetRoutes() []*TripRoute {
	if x != nil {
		return x.Routes
	}
	return nil
}

type TripLeg_LaneConnectivity struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	FromWayId     uint64                 `protobuf:"varint,1,opt,name=from_way_id,json=fromWayId,proto3" json:"from_way_id,omitempty"`
	FromLanes     string                 `protobuf:"bytes,2,opt,name=from_lanes,json=fromLanes,proto3" json:"from_lanes,omitempty"`
	ToLanes       string                 `protobuf:"bytes,3,opt,name=to_lanes,json=toLanes,proto3" json:"to_lanes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TripLeg_LaneConnectivity) Reset() {
	*x = TripLeg_LaneConnectivity{}
	mi := &file_trip_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TripLeg_LaneConnectivity) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TripLeg_LaneConnectivity) ProtoMessage() {}

func (x *TripLeg_LaneConnectivity) ProtoReflect() protoreflect.Message {
	mi := &file_trip_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TripLeg_LaneConnectivity.ProtoReflect.Descriptor instead.
func (*TripLeg_LaneConnectivity) Descriptor() ([]byte, []int) {
	return file_trip_proto_rawDescGZIP(), []int{0, 0}
}

func (x *TripLeg_LaneConnectivity) GetFromWayId() uint64 {
	if x != nil {
		return x.FromWayId
	}
	return 0
}

func (x *TripLeg_LaneConnectivity) GetFromLanes() string {
	if x != nil {
		return x.FromLanes
	}
	return ""
}

func (x *TripLeg_LaneConnectivity) GetToLanes() string {
	if x != nil {
		return x.ToLanes
	}
	return ""
}

type TripLeg_TrafficSegment struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SegmentId     uint64                 `protobuf:"varint,1,opt,name=segment_id,json=segmentId,proto3" json:"segment_id,omitempty"`
	BeginPercent  float32                `protobuf:"fixed32,2,opt,name=begin_percent,json=beginPercent,proto3" json:"begin_percent,omitempty"`
	EndPercent    float32                `protobuf:"fixed32,3,opt,name=end_percent,json=endPercent,proto3" json:"end_percent,omitempty"`
	StartsSegment bool                   `protobuf:"varint,4,opt,name=starts_segment,json=startsSegment,proto3" json:"starts_segment,omitempty"`
	EndsSegment   bool                   `protobuf:"varint,5,opt,name=ends_segment,json=endsSegment,proto3" json:"ends_segment,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TripLeg_TrafficSegment) Reset() {
	*x = TripLeg_TrafficSegment{}
	mi := &file_trip_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TripLeg_TrafficSegment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TripLeg_TrafficSegment) ProtoMessage() {}

func (x *TripLeg_TrafficSegment) ProtoReflect() protoreflect.Message {
	mi := &file_trip_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TripLeg_TrafficSegment.ProtoReflect.Descriptor instead.
func (*TripLeg_TrafficSegment) Descriptor() ([]byte, []int) {
	return file_trip_proto_rawDescGZIP(), []int{0, 1}
}

func (x *TripLeg_TrafficSegment) GetSegmentId() uint64 {
	if x != nil {
		return x.SegmentId
	}
	return 0
}

func (x *TripLeg_TrafficSegment) GetBeginPercent() float32 {
	if x != nil {
		return x.BeginPercent
	}
	return 0
}

func (x *TripLeg_TrafficSegment) GetEndPercent() float32 {
	if x != nil {
		return x.EndPercent
	}
	return 0
}

func (x *TripLeg_TrafficSegment) GetStartsSegment() bool {
	if x != nil {
		return x.StartsSegment
	}
	return false
}

func (x *TripLeg_TrafficSegment) GetEndsSegment() bool {
	if x != nil {
		return x.EndsSegment
	}
	return false
}

type TripLeg_Restriction struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Type          uint32                 `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TripLeg_Restriction) Reset() {
	*x = TripLeg_Restriction{}
	mi := &file_trip_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TripLeg_Restriction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TripLeg_Restriction) ProtoMessage() {}

func (x *TripLeg_Restriction) ProtoReflect() protoreflect.Message {
	mi := &file_trip_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TripLeg_Restriction.ProtoReflect.Descriptor instead.
func (*TripLeg_Restriction) Descriptor() ([]byte, []int) {
	return file_trip_proto_rawDescGZIP(), []int{0, 2}
}

func (x *TripLeg_Restriction) GetType() uint32 {
	if x != nil {
		return x.Type
	}
	return 0
}

// represents a single date/time range from https://wiki.openstreetmap.org/wiki/Key:opening_hours
type TripLeg_TimeDomain struct {
	state         protoimpl.MessageState        `protogen:"open.v1"`
	DayDowType    TripLeg_TimeDomain_DayDowType `protobuf:"varint,1,opt,name=day_dow_type,json=dayDowType,proto3,enum=valhalla.TripLeg_TimeDomain_DayDowType" json:"day_dow_type,omitempty"` // `begin_day_dow` and `end_day_dow` type
	DowMask       uint32                        `protobuf:"varint,2,opt,name=dow_mask,json=dowMask,proto3" json:"dow_mask,omitempty"`                                                        // day of week mask, e.g. 0b0111110 for Mo-Fr as week starts from Su
	BeginHrs      uint32                        `protobuf:"varint,3,opt,name=begin_hrs,json=beginHrs,proto3" json:"begin_hrs,omitempty"`                                                     // begin hours, 0 if not set
	BeginMins     uint32                        `protobuf:"varint,4,opt,name=begin_mins,json=beginMins,proto3" json:"begin_mins,omitempty"`                                                  // begin minutes, 0 if not set
	BeginMonth    uint32                        `protobuf:"varint,5,opt,name=begin_month,json=beginMonth,proto3" json:"begin_month,omitempty"`                                               // begin month, from 1 (January) to 12 (December), 0 if not set
	BeginDayDow   uint32                        `protobuf:"varint,6,opt,name=begin_day_dow,json=beginDayDow,proto3" json:"begin_day_dow,omitempty"`                                          // begin day of month or nth dow, i.e. 1st Sunday
	BeginWeek     uint32                        `protobuf:"varint,7,opt,name=begin_week,json=beginWeek,proto3" json:"begin_week,omitempty"`                                                  // which week does this start, i.e. 1st week in Oct
	EndHrs        uint32                        `protobuf:"varint,8,opt,name=end_hrs,json=endHrs,proto3" json:"end_hrs,omitempty"`                                                           // end hours, 0 if not set
	EndMins       uint32                        `protobuf:"varint,9,opt,name=end_mins,json=endMins,proto3" json:"end_mins,omitempty"`                                                        // end minutes, 0 if not set
	EndMonth      uint32                        `protobuf:"varint,10,opt,name=end_month,json=endMonth,proto3" json:"end_month,omitempty"`                                                    // end month, from 1 (January) to 12 (December), 0 if not set
	EndDayDow     uint32                        `protobuf:"varint,11,opt,name=end_day_dow,json=endDayDow,proto3" json:"end_day_dow,omitempty"`                                               // end day of month or nth dow, i.e. last Sunday
	EndWeek       uint32                        `protobuf:"varint,12,opt,name=end_week,json=endWeek,proto3" json:"end_week,omitempty"`                                                       // which week does this end, i.e. last week in Oct
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TripLeg_TimeDomain) Reset() {
	*x = TripLeg_TimeDomain{}
	mi := &file_trip_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TripLeg_TimeDomain) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TripLeg_TimeDomain) ProtoMessage() {}

func (x *TripLeg_TimeDomain) ProtoReflect() protoreflect.Message {
	mi := &file_trip_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TripLeg_TimeDomain.ProtoReflect.Descriptor instead.
func (*TripLeg_TimeDomain) Descriptor() ([]byte, []int) {
	return file_trip_proto_rawDescGZIP(), []int{0, 3}
}

func (x *TripLeg_TimeDomain) GetDayDowType() TripLeg_TimeDomain_DayDowType {
	if x != nil {
		return x.DayDowType
	}
	return TripLeg_TimeDomain_kDayOfMonth
}

func (x *TripLeg_TimeDomain) GetDowMask() uint32 {
	if x != nil {
		return x.DowMask
	}
	return 0
}

func (x *TripLeg_TimeDomain) GetBeginHrs() uint32 {
	if x != nil {
		return x.BeginHrs
	}
	return 0
}

func (x *TripLeg_TimeDomain) GetBeginMins() uint32 {
	if x != nil {
		return x.BeginMins
	}
	return 0
}

func (x *TripLeg_TimeDomain) GetBeginMonth() uint32 {
	if x != nil {
		return x.BeginMonth
	}
	return 0
}

func (x *TripLeg_TimeDomain) GetBeginDayDow() uint32 {
	if x != nil {
		return x.BeginDayDow
	}
	return 0
}

func (x *TripLeg_TimeDomain) GetBeginWeek() uint32 {
	if x != nil {
		return x.BeginWeek
	}
	return 0
}

func (x *TripLeg_TimeDomain) GetEndHrs() uint32 {
	if x != nil {
		return x.EndHrs
	}
	return 0
}

func (x *TripLeg_TimeDomain) GetEndMins() uint32 {
	if x != nil {
		return x.EndMins
	}
	return 0
}

func (x *TripLeg_TimeDomain) GetEndMonth() uint32 {
	if x != nil {
		return x.EndMonth
	}
	return 0
}

func (x *TripLeg_TimeDomain) GetEndDayDow() uint32 {
	if x != nil {
		return x.EndDayDow
	}
	return 0
}

func (x *TripLeg_TimeDomain) GetEndWeek() uint32 {
	if x != nil {
		return x.EndWeek
	}
	return 0
}

type TripLeg_ConditionalSpeedLimit struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SpeedLimit    uint32                 `protobuf:"varint,1,opt,name=speed_limit,json=speedLimit,proto3" json:"speed_limit,omitempty"`
	Condition     *TripLeg_TimeDomain    `protobuf:"bytes,2,opt,name=condition,proto3" json:"condition,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TripLeg_ConditionalSpeedLimit) Reset() {
	*x = TripLeg_ConditionalSpeedLimit{}
	mi := &file_trip_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TripLeg_ConditionalSpeedLimit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TripLeg_ConditionalSpeedLimit) ProtoMessage() {}

func (x *TripLeg_ConditionalSpeedLimit) ProtoReflect() protoreflect.Message {
	mi := &file_trip_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TripLeg_ConditionalSpeedLimit.ProtoReflect.Descriptor instead.
func (*TripLeg_ConditionalSpeedLimit) Descriptor() ([]byte, []int) {
	return file_trip_proto_rawDescGZIP(), []int{0, 4}
}

func (x *TripLeg_ConditionalSpeedLimit) GetSpeedLimit() uint32 {
	if x != nil {
		return x.SpeedLimit
	}
	return 0
}

func (x *TripLeg_ConditionalSpeedLimit) GetCondition() *TripLeg_TimeDomain {
	if x != nil {
		return x.Condition
	}
	return nil
}

type TripLeg_Edge struct {
	state                protoimpl.MessageState      `protogen:"open.v1"`
	Name                 []*StreetName               `protobuf:"bytes,1,rep,name=name,proto3" json:"name,omitempty"`                           // street names
	LengthKm             float32                     `protobuf:"fixed32,2,opt,name=length_km,json=lengthKm,proto3" json:"length_km,omitempty"` // km
	Speed                float32                     `protobuf:"fixed32,3,opt,name=speed,proto3" json:"speed,omitempty"`                       // km/h
	RoadClass            RoadClass                   `protobuf:"varint,4,opt,name=road_class,json=roadClass,proto3,enum=valhalla.RoadClass" json:"road_class,omitempty"`
	BeginHeading         uint32                      `protobuf:"varint,5,opt,name=begin_heading,json=beginHeading,proto3" json:"begin_heading,omitempty"`            // 0-359
	EndHeading           uint32                      `protobuf:"varint,6,opt,name=end_heading,json=endHeading,proto3" json:"end_heading,omitempty"`                  // 0-359
	BeginShapeIndex      uint32                      `protobuf:"varint,7,opt,name=begin_shape_index,json=beginShapeIndex,proto3" json:"begin_shape_index,omitempty"` // inclusive
	EndShapeIndex        uint32                      `protobuf:"varint,8,opt,name=end_shape_index,json=endShapeIndex,proto3" json:"end_shape_index,omitempty"`       // inclusive
	Traversability       TripLeg_Traversability      `protobuf:"varint,9,opt,name=traversability,proto3,enum=valhalla.TripLeg_Traversability" json:"traversability,omitempty"`
	Use                  TripLeg_Use                 `protobuf:"varint,10,opt,name=use,proto3,enum=valhalla.TripLeg_Use" json:"use,omitempty"`
	Toll                 bool                        `protobuf:"varint,11,opt,name=toll,proto3" json:"toll,omitempty"`
	Unpaved              bool                        `protobuf:"varint,12,opt,name=unpaved,proto3" json:"unpaved,omitempty"`
	Tunnel               bool                        `protobuf:"varint,13,opt,name=tunnel,proto3" json:"tunnel,omitempty"`
	Bridge               bool                        `protobuf:"varint,14,opt,name=bridge,proto3" json:"bridge,omitempty"`
	Roundabout           bool                        `protobuf:"varint,15,opt,name=roundabout,proto3" json:"roundabout,omitempty"`
	InternalIntersection bool                        `protobuf:"varint,16,opt,name=internal_intersection,json=internalIntersection,proto3" json:"internal_intersection,omitempty"`
	DriveOnLeft          bool                        `protobuf:"varint,17,opt,name=drive_on_left,json=driveOnLeft,proto3" json:"drive_on_left,omitempty"` // [default = false]
	Surface              TripLeg_Surface             `protobuf:"varint,18,opt,name=surface,proto3,enum=valhalla.TripLeg_Surface" json:"surface,omitempty"`
	Sign                 *TripSign                   `protobuf:"bytes,19,opt,name=sign,proto3" json:"sign,omitempty"`
	TravelMode           TravelMode                  `protobuf:"varint,20,opt,name=travel_mode,json=travelMode,proto3,enum=valhalla.TravelMode" json:"travel_mode,omitempty"`
	VehicleType          VehicleType                 `protobuf:"varint,21,opt,name=vehicle_type,json=vehicleType,proto3,enum=valhalla.VehicleType" json:"vehicle_type,omitempty"`
	PedestrianType       PedestrianType              `protobuf:"varint,22,opt,name=pedestrian_type,json=pedestrianType,proto3,enum=valhalla.PedestrianType" json:"pedestrian_type,omitempty"`
	BicycleType          BicycleType                 `protobuf:"varint,23,opt,name=bicycle_type,json=bicycleType,proto3,enum=valhalla.BicycleType" json:"bicycle_type,omitempty"`
	TransitType          TransitType                 `protobuf:"varint,24,opt,name=transit_type,json=transitType,proto3,enum=valhalla.TransitType" json:"transit_type,omitempty"`
	TransitRouteInfo     *TransitRouteInfo           `protobuf:"bytes,25,opt,name=transit_route_info,json=transitRouteInfo,proto3" json:"transit_route_info,omitempty"`
	Id                   uint64                      `protobuf:"varint,26,opt,name=id,proto3" json:"id,omitempty"`
	WayId                uint64                      `protobuf:"varint,27,opt,name=way_id,json=wayId,proto3" json:"way_id,omitempty"`
	WeightedGrade        float32                     `protobuf:"fixed32,28,opt,name=weighted_grade,json=weightedGrade,proto3" json:"weighted_grade,omitempty"`
	MaxUpwardGrade       int32                       `protobuf:"varint,29,opt,name=max_upward_grade,json=maxUpwardGrade,proto3" json:"max_upward_grade,omitempty"`       // set to 32768 if no elevation data
	MaxDownwardGrade     int32                       `protobuf:"varint,30,opt,name=max_downward_grade,json=maxDownwardGrade,proto3" json:"max_downward_grade,omitempty"` // set to 32768 if no elevation data
	LaneCount            uint32                      `protobuf:"varint,31,opt,name=lane_count,json=laneCount,proto3" json:"lane_count,omitempty"`
	CycleLane            TripLeg_CycleLane           `protobuf:"varint,32,opt,name=cycle_lane,json=cycleLane,proto3,enum=valhalla.TripLeg_CycleLane" json:"cycle_lane,omitempty"`
	BicycleNetwork       bool                        `protobuf:"varint,33,opt,name=bicycle_network,json=bicycleNetwork,proto3" json:"bicycle_network,omitempty"` // true if the edge is part of a bike network
	Sidewalk             TripLeg_Sidewalk            `protobuf:"varint,34,opt,name=sidewalk,proto3,enum=valhalla.TripLeg_Sidewalk" json:"sidewalk,omitempty"`
	Density              uint32                      `protobuf:"varint,35,opt,name=density,proto3" json:"density,omitempty"`
	SpeedLimit           uint32                      `protobuf:"varint,36,opt,name=speed_limit,json=speedLimit,proto3" json:"speed_limit,omitempty"`  // 0 if unavailable, 255 if unlimited
	TruckSpeed           float32                     `protobuf:"fixed32,37,opt,name=truck_speed,json=truckSpeed,proto3" json:"truck_speed,omitempty"` // km/h, 0 if unavailable
	TruckRoute           bool                        `protobuf:"varint,38,opt,name=truck_route,json=truckRoute,proto3" json:"truck_route,omitempty"`
	LaneConnectivity     []*TripLeg_LaneConnectivity `protobuf:"bytes,39,rep,name=lane_connectivity,json=laneConnectivity,proto3" json:"lane_connectivity,omitempty"`
	MeanElevation        int32                       `protobuf:"varint,40,opt,name=mean_elevation,json=meanElevation,proto3" json:"mean_elevation,omitempty"` // set to 32768 if no elevation data
	TrafficSegment       []*TripLeg_TrafficSegment   `protobuf:"bytes,41,rep,name=traffic_segment,json=trafficSegment,proto3" json:"traffic_segment,omitempty"`
	TurnLanes            []*TurnLane                 `protobuf:"bytes,42,rep,name=turn_lanes,json=turnLanes,proto3" json:"turn_lanes,omitempty"`
	HasTimeRestrictions  bool                        `protobuf:"varint,43,opt,name=has_time_restrictions,json=hasTimeRestrictions,proto3" json:"has_time_restrictions,omitempty"`
	DefaultSpeed         float32                     `protobuf:"fixed32,44,opt,name=default_speed,json=defaultSpeed,proto3" json:"default_speed,omitempty"` // km/h
	Restriction          *TripLeg_Restriction        `protobuf:"bytes,45,opt,name=restriction,proto3" json:"restriction,omitempty"`
	DestinationOnly      bool                        `protobuf:"varint,46,opt,name=destination_only,json=destinationOnly,proto3" json:"destination_only,omitempty"`
	IsUrban              bool                        `protobuf:"varint,47,opt,name=is_urban,json=isUrban,proto3" json:"is_urban,omitempty"` // uses edge density to decide if edge is in an urban area
	TaggedValue          []*TaggedValue              `protobuf:"bytes,48,rep,name=tagged_value,json=taggedValue,proto3" json:"tagged_value,omitempty"`
	// for the part of the edge that is used in the path we must know where
	// it starts and ends along the length of the edge as a percentage
	SourceAlongEdge           float32                          `protobuf:"fixed32,49,opt,name=source_along_edge,json=sourceAlongEdge,proto3" json:"source_along_edge,omitempty"`
	TargetAlongEdge           float32                          `protobuf:"fixed32,50,opt,name=target_along_edge,json=targetAlongEdge,proto3" json:"target_along_edge,omitempty"`
	SacScale                  TripLeg_SacScale                 `protobuf:"varint,51,opt,name=sac_scale,json=sacScale,proto3,enum=valhalla.TripLeg_SacScale" json:"sac_scale,omitempty"`
	Shoulder                  bool                             `protobuf:"varint,52,opt,name=shoulder,proto3" json:"shoulder,omitempty"`
	Indoor                    bool                             `protobuf:"varint,53,opt,name=indoor,proto3" json:"indoor,omitempty"`
	Landmarks                 []*RouteLandmark                 `protobuf:"bytes,54,rep,name=landmarks,proto3" json:"landmarks,omitempty"` // landmarks in the trip leg
	TunnelName                []*StreetName                    `protobuf:"bytes,55,rep,name=tunnel_name,json=tunnelName,proto3" json:"tunnel_name,omitempty"`
	ElevationSamplingInterval float32                          `protobuf:"fixed32,56,opt,name=elevation_sampling_interval,json=elevationSamplingInterval,proto3" json:"elevation_sampling_interval,omitempty"`
	Elevation                 []float32                        `protobuf:"fixed32,57,rep,packed,name=elevation,proto3" json:"elevation,omitempty"`
	CountryCrossing           bool                             `protobuf:"varint,58,opt,name=country_crossing,json=countryCrossing,proto3" json:"country_crossing,omitempty"`
	Forward                   bool                             `protobuf:"varint,59,opt,name=forward,proto3" json:"forward,omitempty"`
	ConditionalSpeedLimits    []*TripLeg_ConditionalSpeedLimit `protobuf:"bytes,60,rep,name=conditional_speed_limits,json=conditionalSpeedLimits,proto3" json:"conditional_speed_limits,omitempty"`
	Levels                    []*TripLeg_Edge_Level            `protobuf:"bytes,61,rep,name=levels,proto3" json:"levels,omitempty"`
	LevelPrecision            uint32                           `protobuf:"varint,62,opt,name=level_precision,json=levelPrecision,proto3" json:"level_precision,omitempty"`
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *TripLeg_Edge) Reset() {
	*x = TripLeg_Edge{}
	mi := &file_trip_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TripLeg_Edge) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TripLeg_Edge) ProtoMessage() {}

func (x *TripLeg_Edge) ProtoReflect() protoreflect.Message {
	mi := &file_trip_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TripLeg_Edge.ProtoReflect.Descriptor instead.
func (*TripLeg_Edge) Descriptor() ([]byte, []int) {
	return file_trip_proto_rawDescGZIP(), []int{0, 5}
}

func (x *TripLeg_Edge) GetName() []*StreetName {
	if x != nil {
		return x.Name
	}
	return nil
}

func (x *TripLeg_Edge) GetLengthKm() float32 {
	if x != nil {
		return x.LengthKm
	}
	return 0
}

func (x *TripLeg_Edge) GetSpeed() float32 {
	if x != nil {
		return x.Speed
	}
	return 0
}

func (x *TripLeg_Edge) GetRoadClass() RoadClass {
	if x != nil {
		return x.RoadClass
	}
	return RoadClass_kMotorway
}

func (x *TripLeg_Edge) GetBeginHeading() uint32 {
	if x != nil {
		return x.BeginHeading
	}
	return 0
}

func (x *TripLeg_Edge) GetEndHeading() uint32 {
	if x != nil {
		return x.EndHeading
	}
	return 0
}

func (x *TripLeg_Edge) GetBeginShapeIndex() uint32 {
	if x != nil {
		return x.BeginShapeIndex
	}
	return 0
}

func (x *TripLeg_Edge) GetEndShapeIndex() uint32 {
	if x != nil {
		return x.EndShapeIndex
	}
	return 0
}

func (x *TripLeg_Edge) GetTraversability() TripLeg_Traversability {
	if x != nil {
		return x.Traversability
	}
	return TripLeg_kNone
}

func (x *TripLeg_Edge) GetUse() TripLeg_Use {
	if x != nil {
		return x.Use
	}
	return TripLeg_kRoadUse
}

func (x *TripLeg_Edge) GetToll() bool {
	if x != nil {
		return x.Toll
	}
	return false
}

func (x *TripLeg_Edge) GetUnpaved() bool {
	if x != nil {
		return x.Unpaved
	}
	return false
}

func (x *TripLeg_Edge) GetTunnel() bool {
	if x != nil {
		return x.Tunnel
	}
	return false
}

func (x *TripLeg_Edge) GetBridge() bool {
	if x != nil {
		return x.Bridge
	}
	return false
}

func (x *TripLeg_Edge) GetRoundabout() bool {
	if x != nil {
		return x.Roundabout
	}
	return false
}

func (x *TripLeg_Edge) GetInternalIntersection() bool {
	if x != nil {
		return x.InternalIntersection
	}
	return false
}

func (x *TripLeg_Edge) GetDriveOnLeft() bool {
	if x != nil {
		return x.DriveOnLeft
	}
	return false
}

func (x *TripLeg_Edge) GetSurface() TripLeg_Surface {
	if x != nil {
		return x.Surface
	}
	return TripLeg_kPavedSmooth
}

func (x *TripLeg_Edge) GetSign() *TripSign {
	if x != nil {
		return x.Sign
	}
	return nil
}

func (x *TripLeg_Edge) GetTravelMode() TravelMode {
	if x != nil {
		return x.TravelMode
	}
	return TravelMode_kDrive
}

func (x *TripLeg_Edge) GetVehicleType() VehicleType {
	if x != nil {
		return x.VehicleType
	}
	return VehicleType_kCar
}

func (x *TripLeg_Edge) GetPedestrianType() PedestrianType {
	if x != nil {
		return x.PedestrianType
	}
	return PedestrianType_kFoot
}

func (x *TripLeg_Edge) GetBicycleType() BicycleType {
	if x != nil {
		return x.BicycleType
	}
	return BicycleType_kRoad
}

func (x *TripLeg_Edge) GetTransitType() TransitType {
	if x != nil {
		return x.TransitType
	}
	return TransitType_kTram
}

func (x *TripLeg_Edge) GetTransitRouteInfo() *TransitRouteInfo {
	if x != nil {
		return x.TransitRouteInfo
	}
	return nil
}

func (x *TripLeg_Edge) GetId() uint64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *TripLeg_Edge) GetWayId() uint64 {
	if x != nil {
		return x.WayId
	}
	return 0
}

func (x *TripLeg_Edge) GetWeightedGrade() float32 {
	if x != nil {
		return x.WeightedGrade
	}
	return 0
}

func (x *TripLeg_Edge) GetMaxUpwardGrade() int32 {
	if x != nil {
		return x.MaxUpwardGrade
	}
	return 0
}

func (x *TripLeg_Edge) GetMaxDownwardGrade() int32 {
	if x != nil {
		return x.MaxDownwardGrade
	}
	return 0
}

func (x *TripLeg_Edge) GetLaneCount() uint32 {
	if x != nil {
		return x.LaneCount
	}
	return 0
}

func (x *TripLeg_Edge) GetCycleLane() TripLeg_CycleLane {
	if x != nil {
		return x.CycleLane
	}
	return TripLeg_kNoCycleLane
}

func (x *TripLeg_Edge) GetBicycleNetwork() bool {
	if x != nil {
		return x.BicycleNetwork
	}
	return false
}

func (x *TripLeg_Edge) GetSidewalk() TripLeg_Sidewalk {
	if x != nil {
		return x.Sidewalk
	}
	return TripLeg_kNoSidewalk
}

func (x *TripLeg_Edge) GetDensity() uint32 {
	if x != nil {
		return x.Density
	}
	return 0
}

func (x *TripLeg_Edge) GetSpeedLimit() uint32 {
	if x != nil {
		return x.SpeedLimit
	}
	return 0
}

func (x *TripLeg_Edge) GetTruckSpeed() float32 {
	if x != nil {
		return x.TruckSpeed
	}
	return 0
}

func (x *TripLeg_Edge) GetTruckRoute() bool {
	if x != nil {
		return x.TruckRoute
	}
	return false
}

func (x *TripLeg_Edge) GetLaneConnectivity() []*TripLeg_LaneConnectivity {
	if x != nil {
		return x.LaneConnectivity
	}
	return nil
}

func (x *TripLeg_Edge) GetMeanElevation() int32 {
	if x != nil {
		return x.MeanElevation
	}
	return 0
}

func (x *TripLeg_Edge) GetTrafficSegment() []*TripLeg_TrafficSegment {
	if x != nil {
		return x.TrafficSegment
	}
	return nil
}

func (x *TripLeg_Edge) GetTurnLanes() []*TurnLane {
	if x != nil {
		return x.TurnLanes
	}
	return nil
}

func (x *TripLeg_Edge) GetHasTimeRestrictions() bool {
	if x != nil {
		return x.HasTimeRestrictions
	}
	return false
}

func (x *TripLeg_Edge) GetDefaultSpeed() float32 {
	if x != nil {
		return x.DefaultSpeed
	}
	return 0
}

func (x *TripLeg_Edge) GetRestriction() *TripLeg_Restriction {
	if x != nil {
		return x.Restriction
	}
	return nil
}

func (x *TripLeg_Edge) GetDestinationOnly() bool {
	if x != nil {
		return x.DestinationOnly
	}
	return false
}

func (x *TripLeg_Edge) GetIsUrban() bool {
	if x != nil {
		return x.IsUrban
	}
	return false
}

func (x *TripLeg_Edge) GetTaggedValue() []*TaggedValue {
	if x != nil {
		return x.TaggedValue
	}
	return nil
}

func (x *TripLeg_Edge) GetSourceAlongEdge() float32 {
	if x != nil {
		return x.SourceAlongEdge
	}
	return 0
}

func (x *TripLeg_Edge) GetTargetAlongEdge() float32 {
	if x != nil {
		return x.TargetAlongEdge
	}
	return 0
}

func (x *TripLeg_Edge) GetSacScale() TripLeg_SacScale {
	if x != nil {
		return x.SacScale
	}
	return TripLeg_kNoSacScale
}

func (x *TripLeg_Edge) GetShoulder() bool {
	if x != nil {
		return x.Shoulder
	}
	return false
}

func (x *TripLeg_Edge) GetIndoor() bool {
	if x != nil {
		return x.Indoor
	}
	return false
}

func (x *TripLeg_Edge) GetLandmarks() []*RouteLandmark {
	if x != nil {
		return x.Landmarks
	}
	return nil
}

func (x *TripLeg_Edge) GetTunnelName() []*StreetName {
	if x != nil {
		return x.TunnelName
	}
	return nil
}

func (x *TripLeg_Edge) GetElevationSamplingInterval() float32 {
	if x != nil {
		return x.ElevationSamplingInterval
	}
	return 0
}

func (x *TripLeg_Edge) GetElevation() []float32 {
	if x != nil {
		return x.Elevation
	}
	return nil
}

func (x *TripLeg_Edge) GetCountryCrossing() bool {
	if x != nil {
		return x.CountryCrossing
	}
	return false
}

func (x *TripLeg_Edge) GetForward() bool {
	if x != nil {
		return x.Forward
	}
	return false
}

func (x *TripLeg_Edge) GetConditionalSpeedLimits() []*TripLeg_ConditionalSpeedLimit {
	if x != nil {
		return x.ConditionalSpeedLimits
	}
	return nil
}

func (x *TripLeg_Edge) GetLevels() []*TripLeg_Edge_Level {
	if x != nil {
		return x.Levels
	}
	return nil
}

func (x *TripLeg_Edge) GetLevelPrecision() uint32 {
	if x != nil {
		return x.LevelPrecision
	}
	return 0
}

type TripLeg_IntersectingEdge struct {
	state               protoimpl.MessageState `protogen:"open.v1"`
	BeginHeading        uint32                 `protobuf:"varint,1,opt,name=begin_heading,json=beginHeading,proto3" json:"begin_heading,omitempty"` // 0-359
	PrevNameConsistency bool                   `protobuf:"varint,2,opt,name=prev_name_consistency,json=prevNameConsistency,proto3" json:"prev_name_consistency,omitempty"`
	CurrNameConsistency bool                   `protobuf:"varint,3,opt,name=curr_name_consistency,json=currNameConsistency,proto3" json:"curr_name_consistency,omitempty"`
	Driveability        TripLeg_Traversability `protobuf:"varint,4,opt,name=driveability,proto3,enum=valhalla.TripLeg_Traversability" json:"driveability,omitempty"`
	Cyclability         TripLeg_Traversability `protobuf:"varint,5,opt,name=cyclability,proto3,enum=valhalla.TripLeg_Traversability" json:"cyclability,omitempty"`
	Walkability         TripLeg_Traversability `protobuf:"varint,6,opt,name=walkability,proto3,enum=valhalla.TripLeg_Traversability" json:"walkability,omitempty"`
	Use                 TripLeg_Use            `protobuf:"varint,7,opt,name=use,proto3,enum=valhalla.TripLeg_Use" json:"use,omitempty"`
	RoadClass           RoadClass              `protobuf:"varint,8,opt,name=road_class,json=roadClass,proto3,enum=valhalla.RoadClass" json:"road_class,omitempty"`
	LaneCount           uint32                 `protobuf:"varint,9,opt,name=lane_count,json=laneCount,proto3" json:"lane_count,omitempty"`
	Sign                *TripSign              `protobuf:"bytes,10,opt,name=sign,proto3" json:"sign,omitempty"`
	Name                []*StreetName          `protobuf:"bytes,21,rep,name=name,proto3" json:"name,omitempty"` // street names
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *TripLeg_IntersectingEdge) Reset() {
	*x = TripLeg_IntersectingEdge{}
	mi := &file_trip_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TripLeg_IntersectingEdge) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TripLeg_IntersectingEdge) ProtoMessage() {}

func (x *TripLeg_IntersectingEdge) ProtoReflect() protoreflect.Message {
	mi := &file_trip_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TripLeg_IntersectingEdge.ProtoReflect.Descriptor instead.
func (*TripLeg_IntersectingEdge) Descriptor() ([]byte, []int) {
	return file_trip_proto_rawDescGZIP(), []int{0, 6}
}

func (x *TripLeg_IntersectingEdge) GetBeginHeading() uint32 {
	if x != nil {
		return x.BeginHeading
	}
	return 0
}

func (x *TripLeg_IntersectingEdge) GetPrevNameConsistency() bool {
	if x != nil {
		return x.PrevNameConsistency
	}
	return false
}

func (x *TripLeg_IntersectingEdge) GetCurrNameConsistency() bool {
	if x != nil {
		return x.CurrNameConsistency
	}
	return false
}

func (x *TripLeg_IntersectingEdge) GetDriveability() TripLeg_Traversability {
	if x != nil {
		return x.Driveability
	}
	return TripLeg_kNone
}

func (x *TripLeg_IntersectingEdge) GetCyclability() TripLeg_Traversability {
	if x != nil {
		return x.Cyclability
	}
	return TripLeg_kNone
}

func (x *TripLeg_IntersectingEdge) GetWalkability() TripLeg_Traversability {
	if x != nil {
		return x.Walkability
	}
	return TripLeg_kNone
}

func (x *TripLeg_IntersectingEdge) GetUse() TripLeg_Use {
	if x != nil {
		return x.Use
	}
	return TripLeg_kRoadUse
}

func (x *TripLeg_IntersectingEdge) GetRoadClass() RoadClass {
	if x != nil {
		return x.RoadClass
	}
	return RoadClass_kMotorway
}

func (x *TripLeg_IntersectingEdge) GetLaneCount() uint32 {
	if x != nil {
		return x.LaneCount
	}
	return 0
}

func (x *TripLeg_IntersectingEdge) GetSign() *TripSign {
	if x != nil {
		return x.Sign
	}
	return nil
}

func (x *TripLeg_IntersectingEdge) GetName() []*StreetName {
	if x != nil {
		return x.Name
	}
	return nil
}

type TripLeg_Cost struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Seconds       float64                `protobuf:"fixed64,1,opt,name=seconds,proto3" json:"seconds,omitempty"`
	Cost          float64                `protobuf:"fixed64,2,opt,name=cost,proto3" json:"cost,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TripLeg_Cost) Reset() {
	*x = TripLeg_Cost{}
	mi := &file_trip_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TripLeg_Cost) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TripLeg_Cost) ProtoMessage() {}

func (x *TripLeg_Cost) ProtoReflect() protoreflect.Message {
	mi := &file_trip_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TripLeg_Cost.ProtoReflect.Descriptor instead.
func (*TripLeg_Cost) Descriptor() ([]byte, []int) {
	return file_trip_proto_rawDescGZIP(), []int{0, 7}
}

func (x *TripLeg_Cost) GetSeconds() float64 {
	if x != nil {
		return x.Seconds
	}
	return 0
}

func (x *TripLeg_Cost) GetCost() float64 {
	if x != nil {
		return x.Cost
	}
	return 0
}

type TripLeg_PathCost struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	ElapsedCost    *TripLeg_Cost          `protobuf:"bytes,1,opt,name=elapsed_cost,json=elapsedCost,proto3" json:"elapsed_cost,omitempty"`
	TransitionCost *TripLeg_Cost          `protobuf:"bytes,2,opt,name=transition_cost,json=transitionCost,proto3" json:"transition_cost,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *TripLeg_PathCost) Reset() {
	*x = TripLeg_PathCost{}
	mi := &file_trip_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TripLeg_PathCost) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TripLeg_PathCost) ProtoMessage() {}

func (x *TripLeg_PathCost) ProtoReflect() protoreflect.Message {
	mi := &file_trip_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TripLeg_PathCost.ProtoReflect.Descriptor instead.
func (*TripLeg_PathCost) Descriptor() ([]byte, []int) {
	return file_trip_proto_rawDescGZIP(), []int{0, 8}
}

func (x *TripLeg_PathCost) GetElapsedCost() *TripLeg_Cost {
	if x != nil {
		return x.ElapsedCost
	}
	return nil
}

func (x *TripLeg_PathCost) GetTransitionCost() *TripLeg_Cost {
	if x != nil {
		return x.TransitionCost
	}
	return nil
}

type TripLeg_Node struct {
	state               protoimpl.MessageState      `protogen:"open.v1"`
	Edge                *TripLeg_Edge               `protobuf:"bytes,1,opt,name=edge,proto3" json:"edge,omitempty"`
	IntersectingEdge    []*TripLeg_IntersectingEdge `protobuf:"bytes,2,rep,name=intersecting_edge,json=intersectingEdge,proto3" json:"intersecting_edge,omitempty"`
	AdminIndex          uint32                      `protobuf:"varint,3,opt,name=admin_index,json=adminIndex,proto3" json:"admin_index,omitempty"`   // index into the admin list, 0 if unknown
	Type                TripLeg_Node_Type           `protobuf:"varint,4,opt,name=type,proto3,enum=valhalla.TripLeg_Node_Type" json:"type,omitempty"` // The type of node
	Fork                bool                        `protobuf:"varint,5,opt,name=fork,proto3" json:"fork,omitempty"`                                 // Fork
	TransitPlatformInfo *TransitPlatformInfo        `protobuf:"bytes,6,opt,name=transit_platform_info,json=transitPlatformInfo,proto3" json:"transit_platform_info,omitempty"`
	TransitStationInfo  *TransitStationInfo         `protobuf:"bytes,7,opt,name=transit_station_info,json=transitStationInfo,proto3" json:"transit_station_info,omitempty"`
	TransitEgressInfo   *TransitEgressInfo          `protobuf:"bytes,10,opt,name=transit_egress_info,json=transitEgressInfo,proto3" json:"transit_egress_info,omitempty"`
	TimeZone            string                      `protobuf:"bytes,11,opt,name=time_zone,json=timeZone,proto3" json:"time_zone,omitempty"`
	Cost                *TripLeg_PathCost           `protobuf:"bytes,12,opt,name=cost,proto3" json:"cost,omitempty"`       // how much cost did it take at this node in the path
	Recosts             []*TripLeg_PathCost         `protobuf:"bytes,13,rep,name=recosts,proto3" json:"recosts,omitempty"` // how much cost did it take at this node in the path for recostings
	BssInfo             *BikeShareStationInfo       `protobuf:"bytes,14,opt,name=bss_info,json=bssInfo,proto3" json:"bss_info,omitempty"`
	TrafficSignal       bool                        `protobuf:"varint,21,opt,name=traffic_signal,json=trafficSignal,proto3" json:"traffic_signal,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *TripLeg_Node) Reset() {
	*x = TripLeg_Node{}
	mi := &file_trip_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TripLeg_Node) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TripLeg_Node) ProtoMessage() {}

func (x *TripLeg_Node) ProtoReflect() protoreflect.Message {
	mi := &file_trip_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TripLeg_Node.ProtoReflect.Descriptor instead.
func (*TripLeg_Node) Descriptor() ([]byte, []int) {
	return file_trip_proto_rawDescGZIP(), []int{0, 9}
}

func (x *TripLeg_Node) GetEdge() *TripLeg_Edge {
	if x != nil {
		return x.Edge
	}
	return nil
}

func (x *TripLeg_Node) GetIntersectingEdge() []*TripLeg_IntersectingEdge {
	if x != nil {
		return x.IntersectingEdge
	}
	return nil
}

func (x *TripLeg_Node) GetAdminIndex() uint32 {
	if x != nil {
		return x.AdminIndex
	}
	return 0
}

func (x *TripLeg_Node) GetType() TripLeg_Node_Type {
	if x != nil {
		return x.Type
	}
	return TripLeg_Node_kStreetIntersection
}

func (x *TripLeg_Node) GetFork() bool {
	if x != nil {
		return x.Fork
	}
	return false
}

func (x *TripLeg_Node) GetTransitPlatformInfo() *TransitPlatformInfo {
	if x != nil {
		return x.TransitPlatformInfo
	}
	return nil
}

func (x *TripLeg_Node) GetTransitStationInfo() *TransitStationInfo {
	if x != nil {
		return x.TransitStationInfo
	}
	return nil
}

func (x *TripLeg_Node) GetTransitEgressInfo() *TransitEgressInfo {
	if x != nil {
		return x.TransitEgressInfo
	}
	return nil
}

func (x *TripLeg_Node) GetTimeZone() string {
	if x != nil {
		return x.TimeZone
	}
	return ""
}

func (x *TripLeg_Node) GetCost() *TripLeg_PathCost {
	if x != nil {
		return x.Cost
	}
	return nil
}

func (x *TripLeg_Node) GetRecosts() []*TripLeg_PathCost {
	if x != nil {
		return x.Recosts
	}
	return nil
}

func (x *TripLeg_Node) GetBssInfo() *BikeShareStationInfo {
	if x != nil {
		return x.BssInfo
	}
	return nil
}

func (x *TripLeg_Node) GetTrafficSignal() bool {
	if x != nil {
		return x.TrafficSignal
	}
	return false
}

type TripLeg_Admin struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	CountryCode   string                 `protobuf:"bytes,1,opt,name=country_code,json=countryCode,proto3" json:"country_code,omitempty"`
	CountryText   string                 `protobuf:"bytes,2,opt,name=country_text,json=countryText,proto3" json:"country_text,omitempty"`
	StateCode     string                 `protobuf:"bytes,3,opt,name=state_code,json=stateCode,proto3" json:"state_code,omitempty"`
	StateText     string                 `protobuf:"bytes,4,opt,name=state_text,json=stateText,proto3" json:"state_text,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TripLeg_Admin) Reset() {
	*x = TripLeg_Admin{}
	mi := &file_trip_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TripLeg_Admin) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TripLeg_Admin) ProtoMessage() {}

func (x *TripLeg_Admin) ProtoReflect() protoreflect.Message {
	mi := &file_trip_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TripLeg_Admin.ProtoReflect.Descriptor instead.
func (*TripLeg_Admin) Descriptor() ([]byte, []int) {
	return file_trip_proto_rawDescGZIP(), []int{0, 10}
}

func (x *TripLeg_Admin) GetCountryCode() string {
	if x != nil {
		return x.CountryCode
	}
	return ""
}

func (x *TripLeg_Admin) GetCountryText() string {
	if x != nil {
		return x.CountryText
	}
	return ""
}

func (x *TripLeg_Admin) GetStateCode() string {
	if x != nil {
		return x.StateCode
	}
	return ""
}

func (x *TripLeg_Admin) GetStateText() string {
	if x != nil {
		return x.StateText
	}
	return ""
}

type TripLeg_ShapeAttributes struct {
	state  protoimpl.MessageState `protogen:"open.v1"`
	Time   []uint32               `protobuf:"varint,1,rep,packed,name=time,proto3" json:"time,omitempty"`     // milliseconds
	Length []uint32               `protobuf:"varint,2,rep,packed,name=length,proto3" json:"length,omitempty"` // decimeters
	Speed  []uint32               `protobuf:"varint,3,rep,packed,name=speed,proto3" json:"speed,omitempty"`   // decimeters per sec
	// 4 is reserved
	SpeedLimit    []uint32 `protobuf:"varint,5,rep,packed,name=speed_limit,json=speedLimit,proto3" json:"speed_limit,omitempty"` // speed limit in kph
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TripLeg_ShapeAttributes) Reset() {
	*x = TripLeg_ShapeAttributes{}
	mi := &file_trip_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TripLeg_ShapeAttributes) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TripLeg_ShapeAttributes) ProtoMessage() {}

func (x *TripLeg_ShapeAttributes) ProtoReflect() protoreflect.Message {
	mi := &file_trip_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TripLeg_ShapeAttributes.ProtoReflect.Descriptor instead.
func (*TripLeg_ShapeAttributes) Descriptor() ([]byte, []int) {
	return file_trip_proto_rawDescGZIP(), []int{0, 11}
}

func (x *TripLeg_ShapeAttributes) GetTime() []uint32 {
	if x != nil {
		return x.Time
	}
	return nil
}

func (x *TripLeg_ShapeAttributes) GetLength() []uint32 {
	if x != nil {
		return x.Length
	}
	return nil
}

func (x *TripLeg_ShapeAttributes) GetSpeed() []uint32 {
	if x != nil {
		return x.Speed
	}
	return nil
}

func (x *TripLeg_ShapeAttributes) GetSpeedLimit() []uint32 {
	if x != nil {
		return x.SpeedLimit
	}
	return nil
}

// we encapsulate the real incident object here so we can add information
// about where it is along the route, ie once its referenced to the route
type TripLeg_Incident struct {
	state    protoimpl.MessageState  `protogen:"open.v1"`
	Metadata *IncidentsTile_Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Valhalla additions to incident metadata goes here
	BeginShapeIndex uint32 `protobuf:"varint,3,opt,name=begin_shape_index,json=beginShapeIndex,proto3" json:"begin_shape_index,omitempty"`
	EndShapeIndex   uint32 `protobuf:"varint,4,opt,name=end_shape_index,json=endShapeIndex,proto3" json:"end_shape_index,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *TripLeg_Incident) Reset() {
	*x = TripLeg_Incident{}
	mi := &file_trip_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TripLeg_Incident) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TripLeg_Incident) ProtoMessage() {}

func (x *TripLeg_Incident) ProtoReflect() protoreflect.Message {
	mi := &file_trip_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TripLeg_Incident.ProtoReflect.Descriptor instead.
func (*TripLeg_Incident) Descriptor() ([]byte, []int) {
	return file_trip_proto_rawDescGZIP(), []int{0, 12}
}

func (x *TripLeg_Incident) GetMetadata() *IncidentsTile_Metadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *TripLeg_Incident) GetBeginShapeIndex() uint32 {
	if x != nil {
		return x.BeginShapeIndex
	}
	return 0
}

func (x *TripLeg_Incident) GetEndShapeIndex() uint32 {
	if x != nil {
		return x.EndShapeIndex
	}
	return 0
}

type TripLeg_Closure struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to HasBeginShapeIndex:
	//
	//	*TripLeg_Closure_BeginShapeIndex
	HasBeginShapeIndex isTripLeg_Closure_HasBeginShapeIndex `protobuf_oneof:"has_begin_shape_index"`
	// Types that are valid to be assigned to HasEndShapeIndex:
	//
	//	*TripLeg_Closure_EndShapeIndex
	HasEndShapeIndex isTripLeg_Closure_HasEndShapeIndex `protobuf_oneof:"has_end_shape_index"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *TripLeg_Closure) Reset() {
	*x = TripLeg_Closure{}
	mi := &file_trip_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TripLeg_Closure) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TripLeg_Closure) ProtoMessage() {}

func (x *TripLeg_Closure) ProtoReflect() protoreflect.Message {
	mi := &file_trip_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TripLeg_Closure.ProtoReflect.Descriptor instead.
func (*TripLeg_Closure) Descriptor() ([]byte, []int) {
	return file_trip_proto_rawDescGZIP(), []int{0, 13}
}

func (x *TripLeg_Closure) GetHasBeginShapeIndex() isTripLeg_Closure_HasBeginShapeIndex {
	if x != nil {
		return x.HasBeginShapeIndex
	}
	return nil
}

func (x *TripLeg_Closure) GetBeginShapeIndex() uint32 {
	if x != nil {
		if x, ok := x.HasBeginShapeIndex.(*TripLeg_Closure_BeginShapeIndex); ok {
			return x.BeginShapeIndex
		}
	}
	return 0
}

func (x *TripLeg_Closure) GetHasEndShapeIndex() isTripLeg_Closure_HasEndShapeIndex {
	if x != nil {
		return x.HasEndShapeIndex
	}
	return nil
}

func (x *TripLeg_Closure) GetEndShapeIndex() uint32 {
	if x != nil {
		if x, ok := x.HasEndShapeIndex.(*TripLeg_Closure_EndShapeIndex); ok {
			return x.EndShapeIndex
		}
	}
	return 0
}

type isTripLeg_Closure_HasBeginShapeIndex interface {
	isTripLeg_Closure_HasBeginShapeIndex()
}

type TripLeg_Closure_BeginShapeIndex struct {
	BeginShapeIndex uint32 `protobuf:"varint,1,opt,name=begin_shape_index,json=beginShapeIndex,proto3,oneof"`
}

func (*TripLeg_Closure_BeginShapeIndex) isTripLeg_Closure_HasBeginShapeIndex() {}

type isTripLeg_Closure_HasEndShapeIndex interface {
	isTripLeg_Closure_HasEndShapeIndex()
}

type TripLeg_Closure_EndShapeIndex struct {
	EndShapeIndex uint32 `protobuf:"varint,2,opt,name=end_shape_index,json=endShapeIndex,proto3,oneof"`
}

func (*TripLeg_Closure_EndShapeIndex) isTripLeg_Closure_HasEndShapeIndex() {}

type TripLeg_Edge_Level struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Start         float32                `protobuf:"fixed32,1,opt,name=start,proto3" json:"start,omitempty"`
	End           float32                `protobuf:"fixed32,2,opt,name=end,proto3" json:"end,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TripLeg_Edge_Level) Reset() {
	*x = TripLeg_Edge_Level{}
	mi := &file_trip_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TripLeg_Edge_Level) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TripLeg_Edge_Level) ProtoMessage() {}

func (x *TripLeg_Edge_Level) ProtoReflect() protoreflect.Message {
	mi := &file_trip_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TripLeg_Edge_Level.ProtoReflect.Descriptor instead.
func (*TripLeg_Edge_Level) Descriptor() ([]byte, []int) {
	return file_trip_proto_rawDescGZIP(), []int{0, 5, 0}
}

func (x *TripLeg_Edge_Level) GetStart() float32 {
	if x != nil {
		return x.Start
	}
	return 0
}

func (x *TripLeg_Edge_Level) GetEnd() float32 {
	if x != nil {
		return x.End
	}
	return 0
}

var File_trip_proto protoreflect.FileDescriptor

const file_trip_proto_rawDesc = "" +
	"\n" +
	"\n" +
	"trip.proto\x12\bvalhalla\x1a\fcommon.proto\x1a\n" +
	"sign.proto\x1a\x0fincidents.proto\"\xdf=\n" +
	"\aTripLeg\x12#\n" +
	"\rosm_changeset\x18\x01 \x01(\x04R\fosmChangeset\x12\x17\n" +
	"\atrip_id\x18\x02 \x01(\x04R\x06tripId\x12\x15\n" +
	"\x06leg_id\x18\x03 \x01(\rR\x05legId\x12\x1b\n" +
	"\tleg_count\x18\x04 \x01(\rR\blegCount\x12.\n" +
	"\blocation\x18\x05 \x03(\v2\x12.valhalla.LocationR\blocation\x12*\n" +
	"\x04node\x18\x06 \x03(\v2\x16.valhalla.TripLeg.NodeR\x04node\x12-\n" +
	"\x05admin\x18\a \x03(\v2\x17.valhalla.TripLeg.AdminR\x05admin\x12\x14\n" +
	"\x05shape\x18\b \x01(\tR\x05shape\x12)\n" +
	"\x04bbox\x18\t \x01(\v2\x15.valhalla.BoundingBoxR\x04bbox\x12L\n" +
	"\x10shape_attributes\x18\n" +
	" \x01(\v2!.valhalla.TripLeg.ShapeAttributesR\x0fshapeAttributes\x128\n" +
	"\tincidents\x18\v \x03(\v2\x1a.valhalla.TripLeg.IncidentR\tincidents\x12\x1e\n" +
	"\n" +
	"algorithms\x18\f \x03(\tR\n" +
	"algorithms\x125\n" +
	"\bclosures\x18\r \x03(\v2\x19.valhalla.TripLeg.ClosureR\bclosures\x12+\n" +
	"\asummary\x18\x0e \x01(\v2\x11.valhalla.SummaryR\asummary\x12:\n" +
	"\rlevel_changes\x18\x0f \x03(\v2\x15.valhalla.LevelChangeR\flevelChanges\x1al\n" +
	"\x10LaneConnectivity\x12\x1e\n" +
	"\vfrom_way_id\x18\x01 \x01(\x04R\tfromWayId\x12\x1d\n" +
	"\n" +
	"from_lanes\x18\x02 \x01(\tR\tfromLanes\x12\x19\n" +
	"\bto_lanes\x18\x03 \x01(\tR\atoLanes\x1a\xbf\x01\n" +
	"\x0eTrafficSegment\x12\x1d\n" +
	"\n" +
	"segment_id\x18\x01 \x01(\x04R\tsegmentId\x12#\n" +
	"\rbegin_percent\x18\x02 \x01(\x02R\fbeginPercent\x12\x1f\n" +
	"\vend_percent\x18\x03 \x01(\x02R\n" +
	"endPercent\x12%\n" +
	"\x0estarts_segment\x18\x04 \x01(\bR\rstartsSegment\x12!\n" +
	"\fends_segment\x18\x05 \x01(\bR\vendsSegment\x1a!\n" +
	"\vRestriction\x12\x12\n" +
	"\x04type\x18\x01 \x01(\rR\x04type\x1a\xd0\x03\n" +
	"\n" +
	"TimeDomain\x12I\n" +
	"\fday_dow_type\x18\x01 \x01(\x0e2'.valhalla.TripLeg.TimeDomain.DayDowTypeR\n" +
	"dayDowType\x12\x19\n" +
	"\bdow_mask\x18\x02 \x01(\rR\adowMask\x12\x1b\n" +
	"\tbegin_hrs\x18\x03 \x01(\rR\bbeginHrs\x12\x1d\n" +
	"\n" +
	"begin_mins\x18\x04 \x01(\rR\tbeginMins\x12\x1f\n" +
	"\vbegin_month\x18\x05 \x01(\rR\n" +
	"beginMonth\x12\"\n" +
	"\rbegin_day_dow\x18\x06 \x01(\rR\vbeginDayDow\x12\x1d\n" +
	"\n" +
	"begin_week\x18\a \x01(\rR\tbeginWeek\x12\x17\n" +
	"\aend_hrs\x18\b \x01(\rR\x06endHrs\x12\x19\n" +
	"\bend_mins\x18\t \x01(\rR\aendMins\x12\x1b\n" +
	"\tend_month\x18\n" +
	" \x01(\rR\bendMonth\x12\x1e\n" +
	"\vend_day_dow\x18\v \x01(\rR\tendDayDow\x12\x19\n" +
	"\bend_week\x18\f \x01(\rR\aendWeek\"0\n" +
	"\n" +
	"DayDowType\x12\x0f\n" +
	"\vkDayOfMonth\x10\x00\x12\x11\n" +
	"\rkNthDayOfWeek\x10\x01\x1at\n" +
	"\x15ConditionalSpeedLimit\x12\x1f\n" +
	"\vspeed_limit\x18\x01 \x01(\rR\n" +
	"speedLimit\x12:\n" +
	"\tcondition\x18\x02 \x01(\v2\x1c.valhalla.TripLeg.TimeDomainR\tcondition\x1a\x82\x16\n" +
	"\x04Edge\x12(\n" +
	"\x04name\x18\x01 \x03(\v2\x14.valhalla.StreetNameR\x04name\x12\x1b\n" +
	"\tlength_km\x18\x02 \x01(\x02R\blengthKm\x12\x14\n" +
	"\x05speed\x18\x03 \x01(\x02R\x05speed\x122\n" +
	"\n" +
	"road_class\x18\x04 \x01(\x0e2\x13.valhalla.RoadClassR\troadClass\x12#\n" +
	"\rbegin_heading\x18\x05 \x01(\rR\fbeginHeading\x12\x1f\n" +
	"\vend_heading\x18\x06 \x01(\rR\n" +
	"endHeading\x12*\n" +
	"\x11begin_shape_index\x18\a \x01(\rR\x0fbeginShapeIndex\x12&\n" +
	"\x0fend_shape_index\x18\b \x01(\rR\rendShapeIndex\x12H\n" +
	"\x0etraversability\x18\t \x01(\x0e2 .valhalla.TripLeg.TraversabilityR\x0etraversability\x12'\n" +
	"\x03use\x18\n" +
	" \x01(\x0e2\x15.valhalla.TripLeg.UseR\x03use\x12\x12\n" +
	"\x04toll\x18\v \x01(\bR\x04toll\x12\x18\n" +
	"\aunpaved\x18\f \x01(\bR\aunpaved\x12\x16\n" +
	"\x06tunnel\x18\r \x01(\bR\x06tunnel\x12\x16\n" +
	"\x06bridge\x18\x0e \x01(\bR\x06bridge\x12\x1e\n" +
	"\n" +
	"roundabout\x18\x0f \x01(\bR\n" +
	"roundabout\x123\n" +
	"\x15internal_intersection\x18\x10 \x01(\bR\x14internalIntersection\x12\"\n" +
	"\rdrive_on_left\x18\x11 \x01(\bR\vdriveOnLeft\x123\n" +
	"\asurface\x18\x12 \x01(\x0e2\x19.valhalla.TripLeg.SurfaceR\asurface\x12&\n" +
	"\x04sign\x18\x13 \x01(\v2\x12.valhalla.TripSignR\x04sign\x125\n" +
	"\vtravel_mode\x18\x14 \x01(\x0e2\x14.valhalla.TravelModeR\n" +
	"travelMode\x128\n" +
	"\fvehicle_type\x18\x15 \x01(\x0e2\x15.valhalla.VehicleTypeR\vvehicleType\x12A\n" +
	"\x0fpedestrian_type\x18\x16 \x01(\x0e2\x18.valhalla.PedestrianTypeR\x0epedestrianType\x128\n" +
	"\fbicycle_type\x18\x17 \x01(\x0e2\x15.valhalla.BicycleTypeR\vbicycleType\x128\n" +
	"\ftransit_type\x18\x18 \x01(\x0e2\x15.valhalla.TransitTypeR\vtransitType\x12H\n" +
	"\x12transit_route_info\x18\x19 \x01(\v2\x1a.valhalla.TransitRouteInfoR\x10transitRouteInfo\x12\x0e\n" +
	"\x02id\x18\x1a \x01(\x04R\x02id\x12\x15\n" +
	"\x06way_id\x18\x1b \x01(\x04R\x05wayId\x12%\n" +
	"\x0eweighted_grade\x18\x1c \x01(\x02R\rweightedGrade\x12(\n" +
	"\x10max_upward_grade\x18\x1d \x01(\x05R\x0emaxUpwardGrade\x12,\n" +
	"\x12max_downward_grade\x18\x1e \x01(\x05R\x10maxDownwardGrade\x12\x1d\n" +
	"\n" +
	"lane_count\x18\x1f \x01(\rR\tlaneCount\x12:\n" +
	"\n" +
	"cycle_lane\x18  \x01(\x0e2\x1b.valhalla.TripLeg.CycleLaneR\tcycleLane\x12'\n" +
	"\x0fbicycle_network\x18! \x01(\bR\x0ebicycleNetwork\x126\n" +
	"\bsidewalk\x18\" \x01(\x0e2\x1a.valhalla.TripLeg.SidewalkR\bsidewalk\x12\x18\n" +
	"\adensity\x18# \x01(\rR\adensity\x12\x1f\n" +
	"\vspeed_limit\x18$ \x01(\rR\n" +
	"speedLimit\x12\x1f\n" +
	"\vtruck_speed\x18% \x01(\x02R\n" +
	"truckSpeed\x12\x1f\n" +
	"\vtruck_route\x18& \x01(\bR\n" +
	"truckRoute\x12O\n" +
	"\x11lane_connectivity\x18' \x03(\v2\".valhalla.TripLeg.LaneConnectivityR\x10laneConnectivity\x12%\n" +
	"\x0emean_elevation\x18( \x01(\x05R\rmeanElevation\x12I\n" +
	"\x0ftraffic_segment\x18) \x03(\v2 .valhalla.TripLeg.TrafficSegmentR\x0etrafficSegment\x121\n" +
	"\n" +
	"turn_lanes\x18* \x03(\v2\x12.valhalla.TurnLaneR\tturnLanes\x122\n" +
	"\x15has_time_restrictions\x18+ \x01(\bR\x13hasTimeRestrictions\x12#\n" +
	"\rdefault_speed\x18, \x01(\x02R\fdefaultSpeed\x12?\n" +
	"\vrestriction\x18- \x01(\v2\x1d.valhalla.TripLeg.RestrictionR\vrestriction\x12)\n" +
	"\x10destination_only\x18. \x01(\bR\x0fdestinationOnly\x12\x19\n" +
	"\bis_urban\x18/ \x01(\bR\aisUrban\x128\n" +
	"\ftagged_value\x180 \x03(\v2\x15.valhalla.TaggedValueR\vtaggedValue\x12*\n" +
	"\x11source_along_edge\x181 \x01(\x02R\x0fsourceAlongEdge\x12*\n" +
	"\x11target_along_edge\x182 \x01(\x02R\x0ftargetAlongEdge\x127\n" +
	"\tsac_scale\x183 \x01(\x0e2\x1a.valhalla.TripLeg.SacScaleR\bsacScale\x12\x1a\n" +
	"\bshoulder\x184 \x01(\bR\bshoulder\x12\x16\n" +
	"\x06indoor\x185 \x01(\bR\x06indoor\x125\n" +
	"\tlandmarks\x186 \x03(\v2\x17.valhalla.RouteLandmarkR\tlandmarks\x125\n" +
	"\vtunnel_name\x187 \x03(\v2\x14.valhalla.StreetNameR\n" +
	"tunnelName\x12>\n" +
	"\x1belevation_sampling_interval\x188 \x01(\x02R\x19elevationSamplingInterval\x12\x1c\n" +
	"\televation\x189 \x03(\x02R\televation\x12)\n" +
	"\x10country_crossing\x18: \x01(\bR\x0fcountryCrossing\x12\x18\n" +
	"\aforward\x18; \x01(\bR\aforward\x12a\n" +
	"\x18conditional_speed_limits\x18< \x03(\v2'.valhalla.TripLeg.ConditionalSpeedLimitR\x16conditionalSpeedLimits\x124\n" +
	"\x06levels\x18= \x03(\v2\x1c.valhalla.TripLeg.Edge.LevelR\x06levels\x12'\n" +
	"\x0flevel_precision\x18> \x01(\rR\x0elevelPrecision\x1a/\n" +
	"\x05Level\x12\x14\n" +
	"\x05start\x18\x01 \x01(\x02R\x05start\x12\x10\n" +
	"\x03end\x18\x02 \x01(\x02R\x03end\x1a\xbb\x04\n" +
	"\x10IntersectingEdge\x12#\n" +
	"\rbegin_heading\x18\x01 \x01(\rR\fbeginHeading\x122\n" +
	"\x15prev_name_consistency\x18\x02 \x01(\bR\x13prevNameConsistency\x122\n" +
	"\x15curr_name_consistency\x18\x03 \x01(\bR\x13currNameConsistency\x12D\n" +
	"\fdriveability\x18\x04 \x01(\x0e2 .valhalla.TripLeg.TraversabilityR\fdriveability\x12B\n" +
	"\vcyclability\x18\x05 \x01(\x0e2 .valhalla.TripLeg.TraversabilityR\vcyclability\x12B\n" +
	"\vwalkability\x18\x06 \x01(\x0e2 .valhalla.TripLeg.TraversabilityR\vwalkability\x12'\n" +
	"\x03use\x18\a \x01(\x0e2\x15.valhalla.TripLeg.UseR\x03use\x122\n" +
	"\n" +
	"road_class\x18\b \x01(\x0e2\x13.valhalla.RoadClassR\troadClass\x12\x1d\n" +
	"\n" +
	"lane_count\x18\t \x01(\rR\tlaneCount\x12&\n" +
	"\x04sign\x18\n" +
	" \x01(\v2\x12.valhalla.TripSignR\x04sign\x12(\n" +
	"\x04name\x18\x15 \x03(\v2\x14.valhalla.StreetNameR\x04name\x1a4\n" +
	"\x04Cost\x12\x18\n" +
	"\aseconds\x18\x01 \x01(\x01R\aseconds\x12\x12\n" +
	"\x04cost\x18\x02 \x01(\x01R\x04cost\x1a\x86\x01\n" +
	"\bPathCost\x129\n" +
	"\felapsed_cost\x18\x01 \x01(\v2\x16.valhalla.TripLeg.CostR\velapsedCost\x12?\n" +
	"\x0ftransition_cost\x18\x02 \x01(\v2\x16.valhalla.TripLeg.CostR\x0etransitionCost\x1a\xd9\a\n" +
	"\x04Node\x12*\n" +
	"\x04edge\x18\x01 \x01(\v2\x16.valhalla.TripLeg.EdgeR\x04edge\x12O\n" +
	"\x11intersecting_edge\x18\x02 \x03(\v2\".valhalla.TripLeg.IntersectingEdgeR\x10intersectingEdge\x12\x1f\n" +
	"\vadmin_index\x18\x03 \x01(\rR\n" +
	"adminIndex\x12/\n" +
	"\x04type\x18\x04 \x01(\x0e2\x1b.valhalla.TripLeg.Node.TypeR\x04type\x12\x12\n" +
	"\x04fork\x18\x05 \x01(\bR\x04fork\x12Q\n" +
	"\x15transit_platform_info\x18\x06 \x01(\v2\x1d.valhalla.TransitPlatformInfoR\x13transitPlatformInfo\x12N\n" +
	"\x14transit_station_info\x18\a \x01(\v2\x1c.valhalla.TransitStationInfoR\x12transitStationInfo\x12K\n" +
	"\x13transit_egress_info\x18\n" +
	" \x01(\v2\x1b.valhalla.TransitEgressInfoR\x11transitEgressInfo\x12\x1b\n" +
	"\ttime_zone\x18\v \x01(\tR\btimeZone\x12.\n" +
	"\x04cost\x18\f \x01(\v2\x1a.valhalla.TripLeg.PathCostR\x04cost\x124\n" +
	"\arecosts\x18\r \x03(\v2\x1a.valhalla.TripLeg.PathCostR\arecosts\x129\n" +
	"\bbss_info\x18\x0e \x01(\v2\x1e.valhalla.BikeShareStationInfoR\abssInfo\x12%\n" +
	"\x0etraffic_signal\x18\x15 \x01(\bR\rtrafficSignal\"\x98\x02\n" +
	"\x04Type\x12\x17\n" +
	"\x13kStreetIntersection\x10\x00\x12\t\n" +
	"\x05kGate\x10\x01\x12\f\n" +
	"\bkBollard\x10\x02\x12\x0e\n" +
	"\n" +
	"kTollBooth\x10\x03\x12\x12\n" +
	"\x0ekTransitEgress\x10\x04\x12\x13\n" +
	"\x0fkTransitStation\x10\x05\x12\x14\n" +
	"\x10kTransitPlatform\x10\x06\x12\x0e\n" +
	"\n" +
	"kBikeShare\x10\a\x12\f\n" +
	"\bkParking\x10\b\x12\x15\n" +
	"\x11kMotorwayJunction\x10\t\x12\x12\n" +
	"\x0ekBorderControl\x10\n" +
	"\x12\x0f\n" +
	"\vkTollGantry\x10\v\x12\x0f\n" +
	"\vkSumpBuster\x10\f\x12\x15\n" +
	"\x11kBuildingEntrance\x10\r\x12\r\n" +
	"\tkElevator\x10\x0e\x1a\x8b\x01\n" +
	"\x05Admin\x12!\n" +
	"\fcountry_code\x18\x01 \x01(\tR\vcountryCode\x12!\n" +
	"\fcountry_text\x18\x02 \x01(\tR\vcountryText\x12\x1d\n" +
	"\n" +
	"state_code\x18\x03 \x01(\tR\tstateCode\x12\x1d\n" +
	"\n" +
	"state_text\x18\x04 \x01(\tR\tstateText\x1a\x84\x01\n" +
	"\x0fShapeAttributes\x12\x16\n" +
	"\x04time\x18\x01 \x03(\rB\x02\x10\x01R\x04time\x12\x1a\n" +
	"\x06length\x18\x02 \x03(\rB\x02\x10\x01R\x06length\x12\x18\n" +
	"\x05speed\x18\x03 \x03(\rB\x02\x10\x01R\x05speed\x12#\n" +
	"\vspeed_limit\x18\x05 \x03(\rB\x02\x10\x01R\n" +
	"speedLimit\x1a\x9c\x01\n" +
	"\bIncident\x12<\n" +
	"\bmetadata\x18\x01 \x01(\v2 .valhalla.IncidentsTile.MetadataR\bmetadata\x12*\n" +
	"\x11begin_shape_index\x18\x03 \x01(\rR\x0fbeginShapeIndex\x12&\n" +
	"\x0fend_shape_index\x18\x04 \x01(\rR\rendShapeIndex\x1a\x91\x01\n" +
	"\aClosure\x12,\n" +
	"\x11begin_shape_index\x18\x01 \x01(\rH\x00R\x0fbeginShapeIndex\x12(\n" +
	"\x0fend_shape_index\x18\x02 \x01(\rH\x01R\rendShapeIndexB\x17\n" +
	"\x15has_begin_shape_indexB\x15\n" +
	"\x13has_end_shape_index\"C\n" +
	"\x0eTraversability\x12\t\n" +
	"\x05kNone\x10\x00\x12\f\n" +
	"\bkForward\x10\x01\x12\r\n" +
	"\tkBackward\x10\x02\x12\t\n" +
	"\x05kBoth\x10\x03\"\x8f\x05\n" +
	"\x03Use\x12\f\n" +
	"\bkRoadUse\x10\x00\x12\f\n" +
	"\bkRampUse\x10\x01\x12\x13\n" +
	"\x0fkTurnChannelUse\x10\x02\x12\r\n" +
	"\tkTrackUse\x10\x03\x12\x10\n" +
	"\fkDrivewayUse\x10\x04\x12\r\n" +
	"\tkAlleyUse\x10\x05\x12\x14\n" +
	"\x10kParkingAisleUse\x10\x06\x12\x17\n" +
	"\x13kEmergencyAccessUse\x10\a\x12\x11\n" +
	"\rkDriveThruUse\x10\b\x12\x10\n" +
	"\fkCuldesacUse\x10\t\x12\x14\n" +
	"\x10kLivingStreetUse\x10\n" +
	"\x12\x13\n" +
	"\x0fkServiceRoadUse\x10\v\x12\x10\n" +
	"\fkCyclewayUse\x10\x14\x12\x14\n" +
	"\x10kMountainBikeUse\x10\x15\x12\x10\n" +
	"\fkSidewalkUse\x10\x18\x12\x0f\n" +
	"\vkFootwayUse\x10\x19\x12\r\n" +
	"\tkStepsUse\x10\x1a\x12\f\n" +
	"\bkPathUse\x10\x1b\x12\x12\n" +
	"\x0ekPedestrianUse\x10\x1c\x12\x11\n" +
	"\rkBridlewayUse\x10\x1d\x12\x1a\n" +
	"\x16kPedestrianCrossingUse\x10 \x12\x10\n" +
	"\fkElevatorUse\x10!\x12\x11\n" +
	"\rkEscalatorUse\x10\"\x12\x10\n" +
	"\fkRestAreaUse\x10\x1e\x12\x13\n" +
	"\x0fkServiceAreaUse\x10\x1f\x12\r\n" +
	"\tkOtherUse\x10(\x12\r\n" +
	"\tkFerryUse\x10)\x12\x11\n" +
	"\rkRailFerryUse\x10*\x12\x14\n" +
	"\x10kConstructionUse\x10+\x12\f\n" +
	"\bkRailUse\x102\x12\v\n" +
	"\akBusUse\x103\x12\x18\n" +
	"\x14kEgressConnectionUse\x104\x12\x1a\n" +
	"\x16kPlatformConnectionUse\x105\x12\x19\n" +
	"\x15kTransitConnectionUse\x106\"|\n" +
	"\aSurface\x12\x10\n" +
	"\fkPavedSmooth\x10\x00\x12\n" +
	"\n" +
	"\x06kPaved\x10\x01\x12\x0f\n" +
	"\vkPavedRough\x10\x02\x12\x0e\n" +
	"\n" +
	"kCompacted\x10\x03\x12\t\n" +
	"\x05kDirt\x10\x04\x12\v\n" +
	"\akGravel\x10\x05\x12\t\n" +
	"\x05kPath\x10\x06\x12\x0f\n" +
	"\vkImpassable\x10\a\"J\n" +
	"\tCycleLane\x12\x10\n" +
	"\fkNoCycleLane\x10\x00\x12\v\n" +
	"\akShared\x10\x01\x12\x0e\n" +
	"\n" +
	"kDedicated\x10\x02\x12\x0e\n" +
	"\n" +
	"kSeparated\x10\x03\"\xa6\x01\n" +
	"\bSacScale\x12\x0f\n" +
	"\vkNoSacScale\x10\x00\x12\v\n" +
	"\akHiking\x10\x01\x12\x13\n" +
	"\x0fkMountainHiking\x10\x02\x12\x1c\n" +
	"\x18kDemandingMountainHiking\x10\x03\x12\x11\n" +
	"\rkAlpineHiking\x10\x04\x12\x1a\n" +
	"\x16kDemandingAlpineHiking\x10\x05\x12\x1a\n" +
	"\x16kDifficultAlpineHiking\x10\x06\"B\n" +
	"\bSidewalk\x12\x0f\n" +
	"\vkNoSidewalk\x10\x00\x12\t\n" +
	"\x05kLeft\x10\x01\x12\n" +
	"\n" +
	"\x06kRight\x10\x02\x12\x0e\n" +
	"\n" +
	"kBothSides\x10\x03\"2\n" +
	"\tTripRoute\x12%\n" +
	"\x04legs\x18\x01 \x03(\v2\x11.valhalla.TripLegR\x04legs\"3\n" +
	"\x04Trip\x12+\n" +
	"\x06routes\x18\x01 \x03(\v2\x13.valhalla.TripRouteR\x06routesB:H\x03Z6matching-engine/internal/adapter/valhalla/client/pb;pbP\x00P\x01b\x06proto3"

var (
	file_trip_proto_rawDescOnce sync.Once
	file_trip_proto_rawDescData []byte
)

func file_trip_proto_rawDescGZIP() []byte {
	file_trip_proto_rawDescOnce.Do(func() {
		file_trip_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_trip_proto_rawDesc), len(file_trip_proto_rawDesc)))
	})
	return file_trip_proto_rawDescData
}

var file_trip_proto_enumTypes = make([]protoimpl.EnumInfo, 8)
var file_trip_proto_msgTypes = make([]protoimpl.MessageInfo, 18)
var file_trip_proto_goTypes = []any{
	(TripLeg_Traversability)(0),           // 0: valhalla.TripLeg.Traversability
	(TripLeg_Use)(0),                      // 1: valhalla.TripLeg.Use
	(TripLeg_Surface)(0),                  // 2: valhalla.TripLeg.Surface
	(TripLeg_CycleLane)(0),                // 3: valhalla.TripLeg.CycleLane
	(TripLeg_SacScale)(0),                 // 4: valhalla.TripLeg.SacScale
	(TripLeg_Sidewalk)(0),                 // 5: valhalla.TripLeg.Sidewalk
	(TripLeg_TimeDomain_DayDowType)(0),    // 6: valhalla.TripLeg.TimeDomain.DayDowType
	(TripLeg_Node_Type)(0),                // 7: valhalla.TripLeg.Node.Type
	(*TripLeg)(nil),                       // 8: valhalla.TripLeg
	(*TripRoute)(nil),                     // 9: valhalla.TripRoute
	(*Trip)(nil),                          // 10: valhalla.Trip
	(*TripLeg_LaneConnectivity)(nil),      // 11: valhalla.TripLeg.LaneConnectivity
	(*TripLeg_TrafficSegment)(nil),        // 12: valhalla.TripLeg.TrafficSegment
	(*TripLeg_Restriction)(nil),           // 13: valhalla.TripLeg.Restriction
	(*TripLeg_TimeDomain)(nil),            // 14: valhalla.TripLeg.TimeDomain
	(*TripLeg_ConditionalSpeedLimit)(nil), // 15: valhalla.TripLeg.ConditionalSpeedLimit
	(*TripLeg_Edge)(nil),                  // 16: valhalla.TripLeg.Edge
	(*TripLeg_IntersectingEdge)(nil),      // 17: valhalla.TripLeg.IntersectingEdge
	(*TripLeg_Cost)(nil),                  // 18: valhalla.TripLeg.Cost
	(*TripLeg_PathCost)(nil),              // 19: valhalla.TripLeg.PathCost
	(*TripLeg_Node)(nil),                  // 20: valhalla.TripLeg.Node
	(*TripLeg_Admin)(nil),                 // 21: valhalla.TripLeg.Admin
	(*TripLeg_ShapeAttributes)(nil),       // 22: valhalla.TripLeg.ShapeAttributes
	(*TripLeg_Incident)(nil),              // 23: valhalla.TripLeg.Incident
	(*TripLeg_Closure)(nil),               // 24: valhalla.TripLeg.Closure
	(*TripLeg_Edge_Level)(nil),            // 25: valhalla.TripLeg.Edge.Level
	(*Location)(nil),                      // 26: valhalla.Location
	(*BoundingBox)(nil),                   // 27: valhalla.BoundingBox
	(*Summary)(nil),                       // 28: valhalla.Summary
	(*LevelChange)(nil),                   // 29: valhalla.LevelChange
	(*StreetName)(nil),                    // 30: valhalla.StreetName
	(RoadClass)(0),                        // 31: valhalla.RoadClass
	(*TripSign)(nil),                      // 32: valhalla.TripSign
	(TravelMode)(0),                       // 33: valhalla.TravelMode
	(VehicleType)(0),                      // 34: valhalla.VehicleType
	(PedestrianType)(0),                   // 35: valhalla.PedestrianType
	(BicycleType)(0),                      // 36: valhalla.BicycleType
	(TransitType)(0),                      // 37: valhalla.TransitType
	(*TransitRouteInfo)(nil),              // 38: valhalla.TransitRouteInfo
	(*TurnLane)(nil),                      // 39: valhalla.TurnLane
	(*TaggedValue)(nil),                   // 40: valhalla.TaggedValue
	(*RouteLandmark)(nil),                 // 41: valhalla.RouteLandmark
	(*TransitPlatformInfo)(nil),           // 42: valhalla.TransitPlatformInfo
	(*TransitStationInfo)(nil),            // 43: valhalla.TransitStationInfo
	(*TransitEgressInfo)(nil),             // 44: valhalla.TransitEgressInfo
	(*BikeShareStationInfo)(nil),          // 45: valhalla.BikeShareStationInfo
	(*IncidentsTile_Metadata)(nil),        // 46: valhalla.IncidentsTile.Metadata
}
var file_trip_proto_depIdxs = []int32{
	26, // 0: valhalla.TripLeg.location:type_name -> valhalla.Location
	20, // 1: valhalla.TripLeg.node:type_name -> valhalla.TripLeg.Node
	21, // 2: valhalla.TripLeg.admin:type_name -> valhalla.TripLeg.Admin
	27, // 3: valhalla.TripLeg.bbox:type_name -> valhalla.BoundingBox
	22, // 4: valhalla.TripLeg.shape_attributes:type_name -> valhalla.TripLeg.ShapeAttributes
	23, // 5: valhalla.TripLeg.incidents:type_name -> valhalla.TripLeg.Incident
	24, // 6: valhalla.TripLeg.closures:type_name -> valhalla.TripLeg.Closure
	28, // 7: valhalla.TripLeg.summary:type_name -> valhalla.Summary
	29, // 8: valhalla.TripLeg.level_changes:type_name -> valhalla.LevelChange
	8,  // 9: valhalla.TripRoute.legs:type_name -> valhalla.TripLeg
	9,  // 10: valhalla.Trip.routes:type_name -> valhalla.TripRoute
	6,  // 11: valhalla.TripLeg.TimeDomain.day_dow_type:type_name -> valhalla.TripLeg.TimeDomain.DayDowType
	14, // 12: valhalla.TripLeg.ConditionalSpeedLimit.condition:type_name -> valhalla.TripLeg.TimeDomain
	30, // 13: valhalla.TripLeg.Edge.name:type_name -> valhalla.StreetName
	31, // 14: valhalla.TripLeg.Edge.road_class:type_name -> valhalla.RoadClass
	0,  // 15: valhalla.TripLeg.Edge.traversability:type_name -> valhalla.TripLeg.Traversability
	1,  // 16: valhalla.TripLeg.Edge.use:type_name -> valhalla.TripLeg.Use
	2,  // 17: valhalla.TripLeg.Edge.surface:type_name -> valhalla.TripLeg.Surface
	32, // 18: valhalla.TripLeg.Edge.sign:type_name -> valhalla.TripSign
	33, // 19: valhalla.TripLeg.Edge.travel_mode:type_name -> valhalla.TravelMode
	34, // 20: valhalla.TripLeg.Edge.vehicle_type:type_name -> valhalla.VehicleType
	35, // 21: valhalla.TripLeg.Edge.pedestrian_type:type_name -> valhalla.PedestrianType
	36, // 22: valhalla.TripLeg.Edge.bicycle_type:type_name -> valhalla.BicycleType
	37, // 23: valhalla.TripLeg.Edge.transit_type:type_name -> valhalla.TransitType
	38, // 24: valhalla.TripLeg.Edge.transit_route_info:type_name -> valhalla.TransitRouteInfo
	3,  // 25: valhalla.TripLeg.Edge.cycle_lane:type_name -> valhalla.TripLeg.CycleLane
	5,  // 26: valhalla.TripLeg.Edge.sidewalk:type_name -> valhalla.TripLeg.Sidewalk
	11, // 27: valhalla.TripLeg.Edge.lane_connectivity:type_name -> valhalla.TripLeg.LaneConnectivity
	12, // 28: valhalla.TripLeg.Edge.traffic_segment:type_name -> valhalla.TripLeg.TrafficSegment
	39, // 29: valhalla.TripLeg.Edge.turn_lanes:type_name -> valhalla.TurnLane
	13, // 30: valhalla.TripLeg.Edge.restriction:type_name -> valhalla.TripLeg.Restriction
	40, // 31: valhalla.TripLeg.Edge.tagged_value:type_name -> valhalla.TaggedValue
	4,  // 32: valhalla.TripLeg.Edge.sac_scale:type_name -> valhalla.TripLeg.SacScale
	41, // 33: valhalla.TripLeg.Edge.landmarks:type_name -> valhalla.RouteLandmark
	30, // 34: valhalla.TripLeg.Edge.tunnel_name:type_name -> valhalla.StreetName
	15, // 35: valhalla.TripLeg.Edge.conditional_speed_limits:type_name -> valhalla.TripLeg.ConditionalSpeedLimit
	25, // 36: valhalla.TripLeg.Edge.levels:type_name -> valhalla.TripLeg.Edge.Level
	0,  // 37: valhalla.TripLeg.IntersectingEdge.driveability:type_name -> valhalla.TripLeg.Traversability
	0,  // 38: valhalla.TripLeg.IntersectingEdge.cyclability:type_name -> valhalla.TripLeg.Traversability
	0,  // 39: valhalla.TripLeg.IntersectingEdge.walkability:type_name -> valhalla.TripLeg.Traversability
	1,  // 40: valhalla.TripLeg.IntersectingEdge.use:type_name -> valhalla.TripLeg.Use
	31, // 41: valhalla.TripLeg.IntersectingEdge.road_class:type_name -> valhalla.RoadClass
	32, // 42: valhalla.TripLeg.IntersectingEdge.sign:type_name -> valhalla.TripSign
	30, // 43: valhalla.TripLeg.IntersectingEdge.name:type_name -> valhalla.StreetName
	18, // 44: valhalla.TripLeg.PathCost.elapsed_cost:type_name -> valhalla.TripLeg.Cost
	18, // 45: valhalla.TripLeg.PathCost.transition_cost:type_name -> valhalla.TripLeg.Cost
	16, // 46: valhalla.TripLeg.Node.edge:type_name -> valhalla.TripLeg.Edge
	17, // 47: valhalla.TripLeg.Node.intersecting_edge:type_name -> valhalla.TripLeg.IntersectingEdge
	7,  // 48: valhalla.TripLeg.Node.type:type_name -> valhalla.TripLeg.Node.Type
	42, // 49: valhalla.TripLeg.Node.transit_platform_info:type_name -> valhalla.TransitPlatformInfo
	43, // 50: valhalla.TripLeg.Node.transit_station_info:type_name -> valhalla.TransitStationInfo
	44, // 51: valhalla.TripLeg.Node.transit_egress_info:type_name -> valhalla.TransitEgressInfo
	19, // 52: valhalla.TripLeg.Node.cost:type_name -> valhalla.TripLeg.PathCost
	19, // 53: valhalla.TripLeg.Node.recosts:type_name -> valhalla.TripLeg.PathCost
	45, // 54: valhalla.TripLeg.Node.bss_info:type_name -> valhalla.BikeShareStationInfo
	46, // 55: valhalla.TripLeg.Incident.metadata:type_name -> valhalla.IncidentsTile.Metadata
	56, // [56:56] is the sub-list for method output_type
	56, // [56:56] is the sub-list for method input_type
	56, // [56:56] is the sub-list for extension type_name
	56, // [56:56] is the sub-list for extension extendee
	0,  // [0:56] is the sub-list for field type_name
}

func init() { file_trip_proto_init() }
func file_trip_proto_init() {
	if File_trip_proto != nil {
		return
	}
	file_common_proto_init()
	file_sign_proto_init()
	file_incidents_proto_init()
	file_trip_proto_msgTypes[16].OneofWrappers = []any{
		(*TripLeg_Closure_BeginShapeIndex)(nil),
		(*TripLeg_Closure_EndShapeIndex)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_trip_proto_rawDesc), len(file_trip_proto_rawDesc)),
			NumEnums:      8,
			NumMessages:   18,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_trip_proto_goTypes,
		DependencyIndexes: file_trip_proto_depIdxs,
		EnumInfos:         file_trip_proto_enumTypes,
		MessageInfos:      file_trip_proto_msgTypes,
	}.Build()
	File_trip_proto = out.File
	file_trip_proto_goTypes = nil
	file_trip_proto_depIdxs = nil
}
